name,docstring,code,file,module,parent,type,code_start_line,code_end_line,len,generated_docstring
views,,"from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.messages.views import SuccessMessageMixin
from django.shortcuts import HttpResponseRedirect, redirect, render
from django.urls import reverse_lazy
from django.views.generic import ListView, TemplateView, View
from django.views.generic.edit import CreateView, DeleteView, UpdateView
from .forms import AcademicSessionForm, AcademicTermForm, CurrentSessionForm, SiteConfigForm, StudentClassForm, SubjectForm
from .models import AcademicSession, AcademicTerm, SiteConfig, StudentClass, Subject


class IndexView(LoginRequiredMixin, TemplateView):
    template_name = 'index.html'


class SiteConfigView(LoginRequiredMixin, View):
    """"""Site Config View""""""
    form_class = SiteConfigForm
    template_name = 'corecode/siteconfig.html'

    def get(self, request, *args, **kwargs):
        formset = self.form_class(queryset=SiteConfig.objects.all())
        context = {'formset': formset}
        return render(request, self.template_name, context)

    def post(self, request, *args, **kwargs):
        formset = self.form_class(request.POST)
        if formset.is_valid():
            formset.save()
            messages.success(request, 'Configurations successfully updated')
        context = {'formset': formset, 'title': 'Configuration'}
        return render(request, self.template_name, context)


class SessionListView(LoginRequiredMixin, SuccessMessageMixin, ListView):
    model = AcademicSession
    template_name = 'corecode/session_list.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['form'] = AcademicSessionForm()
        return context


class SessionCreateView(LoginRequiredMixin, SuccessMessageMixin, CreateView):
    model = AcademicSession
    form_class = AcademicSessionForm
    template_name = 'corecode/mgt_form.html'
    success_url = reverse_lazy('sessions')
    success_message = 'New session successfully added'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = 'Add new session'
        return context


class SessionUpdateView(LoginRequiredMixin, SuccessMessageMixin, UpdateView):
    model = AcademicSession
    form_class = AcademicSessionForm
    success_url = reverse_lazy('sessions')
    success_message = 'Session successfully updated.'
    template_name = 'corecode/mgt_form.html'

    def form_valid(self, form):
        obj = self.object
        if obj.current == False:
            terms = AcademicSession.objects.filter(current=True).exclude(name
                =obj.name).exists()
            if not terms:
                messages.warning(self.request,
                    'You must set a session to current.')
                return redirect('session-list')
        return super().form_valid(form)


class SessionDeleteView(LoginRequiredMixin, DeleteView):
    model = AcademicSession
    success_url = reverse_lazy('sessions')
    template_name = 'corecode/core_confirm_delete.html'
    success_message = (
        'The session {} has been deleted with all its attached content')

    def delete(self, request, *args, **kwargs):
        obj = self.get_object()
        if obj.current == True:
            messages.warning(request,
                'Cannot delete session as it is set to current')
            return redirect('sessions')
        messages.success(self.request, self.success_message.format(obj.name))
        return super(SessionDeleteView, self).delete(request, *args, **kwargs)


class TermListView(LoginRequiredMixin, SuccessMessageMixin, ListView):
    model = AcademicTerm
    template_name = 'corecode/term_list.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['form'] = AcademicTermForm()
        return context


class TermCreateView(LoginRequiredMixin, SuccessMessageMixin, CreateView):
    model = AcademicTerm
    form_class = AcademicTermForm
    template_name = 'corecode/mgt_form.html'
    success_url = reverse_lazy('terms')
    success_message = 'New term successfully added'


class TermUpdateView(LoginRequiredMixin, SuccessMessageMixin, UpdateView):
    model = AcademicTerm
    form_class = AcademicTermForm
    success_url = reverse_lazy('terms')
    success_message = 'Term successfully updated.'
    template_name = 'corecode/mgt_form.html'

    def form_valid(self, form):
        obj = self.object
        if obj.current == False:
            terms = AcademicTerm.objects.filter(current=True).exclude(name=
                obj.name).exists()
            if not terms:
                messages.warning(self.request,
                    'You must set a term to current.')
                return redirect('term')
        return super().form_valid(form)


class TermDeleteView(LoginRequiredMixin, DeleteView):
    model = AcademicTerm
    success_url = reverse_lazy('terms')
    template_name = 'corecode/core_confirm_delete.html'
    success_message = (
        'The term {} has been deleted with all its attached content')

    def delete(self, request, *args, **kwargs):
        obj = self.get_object()
        if obj.current == True:
            messages.warning(request,
                'Cannot delete term as it is set to current')
            return redirect('terms')
        messages.success(self.request, self.success_message.format(obj.name))
        return super(TermDeleteView, self).delete(request, *args, **kwargs)


class ClassListView(LoginRequiredMixin, SuccessMessageMixin, ListView):
    model = StudentClass
    template_name = 'corecode/class_list.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['form'] = StudentClassForm()
        return context


class ClassCreateView(LoginRequiredMixin, SuccessMessageMixin, CreateView):
    model = StudentClass
    form_class = StudentClassForm
    template_name = 'corecode/mgt_form.html'
    success_url = reverse_lazy('classes')
    success_message = 'New class successfully added'


class ClassUpdateView(LoginRequiredMixin, SuccessMessageMixin, UpdateView):
    model = StudentClass
    fields = ['name']
    success_url = reverse_lazy('classes')
    success_message = 'class successfully updated.'
    template_name = 'corecode/mgt_form.html'


class ClassDeleteView(LoginRequiredMixin, DeleteView):
    model = StudentClass
    success_url = reverse_lazy('classes')
    template_name = 'corecode/core_confirm_delete.html'
    success_message = (
        'The class {} has been deleted with all its attached content')

    def delete(self, request, *args, **kwargs):
        obj = self.get_object()
        print(obj.name)
        messages.success(self.request, self.success_message.format(obj.name))
        return super(ClassDeleteView, self).delete(request, *args, **kwargs)


class SubjectListView(LoginRequiredMixin, SuccessMessageMixin, ListView):
    model = Subject
    template_name = 'corecode/subject_list.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['form'] = SubjectForm()
        return context


class SubjectCreateView(LoginRequiredMixin, SuccessMessageMixin, CreateView):
    model = Subject
    form_class = SubjectForm
    template_name = 'corecode/mgt_form.html'
    success_url = reverse_lazy('subjects')
    success_message = 'New subject successfully added'


class SubjectUpdateView(LoginRequiredMixin, SuccessMessageMixin, UpdateView):
    model = Subject
    fields = ['name']
    success_url = reverse_lazy('subjects')
    success_message = 'Subject successfully updated.'
    template_name = 'corecode/mgt_form.html'


class SubjectDeleteView(LoginRequiredMixin, DeleteView):
    model = Subject
    success_url = reverse_lazy('subjects')
    template_name = 'corecode/core_confirm_delete.html'
    success_message = (
        'The subject {} has been deleted with all its attached content')

    def delete(self, request, *args, **kwargs):
        obj = self.get_object()
        messages.success(self.request, self.success_message.format(obj.name))
        return super(SubjectDeleteView, self).delete(request, *args, **kwargs)


class CurrentSessionAndTermView(LoginRequiredMixin, View):
    """"""Current SEssion and Term""""""
    form_class = CurrentSessionForm
    template_name = 'corecode/current_session.html'

    def get(self, request, *args, **kwargs):
        form = self.form_class(initial={'current_session': AcademicSession.
            objects.get(current=True), 'current_term': AcademicTerm.objects
            .get(current=True)})
        return render(request, self.template_name, {'form': form})

    def post(self, request, *args, **kwargs):
        form = self.form_class(request.POST, initial={'current_session':
            AcademicSession.objects.get(current=True), 'current_term':
            AcademicTerm.objects.get(current=True)})
        if form.is_valid():
            session = form.cleaned_data['current_session']
            term = form.cleaned_data['current_term']
            AcademicSession.objects.filter(name=session).update(current=True)
            AcademicSession.objects.exclude(name=session).update(current=False)
            AcademicTerm.objects.filter(name=term).update(current=True)
        return render(request, self.template_name, {'form': form})
",../../Django-School-Management-System/apps/corecode/views.py,views,,module,0.0,,9495,nan
views,,"from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, render
from django.urls import reverse_lazy
from django.views.generic import DetailView, ListView
from django.views.generic.edit import CreateView, DeleteView, UpdateView
from apps.students.models import Student
from .forms import InvoiceItemFormset, InvoiceReceiptFormSet, Invoices
from .models import Invoice, InvoiceItem, Receipt


class InvoiceListView(LoginRequiredMixin, ListView):
    model = Invoice


class InvoiceCreateView(LoginRequiredMixin, CreateView):
    model = Invoice
    fields = '__all__'
    success_url = '/finance/list'

    def get_context_data(self, **kwargs):
        context = super(InvoiceCreateView, self).get_context_data(**kwargs)
        if self.request.POST:
            context['items'] = InvoiceItemFormset(self.request.POST, prefix
                ='invoiceitem_set')
        else:
            context['items'] = InvoiceItemFormset(prefix='invoiceitem_set')
        return context

    def form_valid(self, form):
        context = self.get_context_data()
        formset = context['items']
        self.object = form.save()
        if self.object.id != None:
            if form.is_valid() and formset.is_valid():
                formset.instance = self.object
                formset.save()
        return super().form_valid(form)


class InvoiceDetailView(LoginRequiredMixin, DetailView):
    model = Invoice
    fields = '__all__'

    def get_context_data(self, **kwargs):
        context = super(InvoiceDetailView, self).get_context_data(**kwargs)
        context['receipts'] = Receipt.objects.filter(invoice=self.object)
        context['items'] = InvoiceItem.objects.filter(invoice=self.object)
        return context


class InvoiceUpdateView(LoginRequiredMixin, UpdateView):
    model = Invoice
    fields = ['student', 'session', 'term', 'class_for',
        'balance_from_previous_term']

    def get_context_data(self, **kwargs):
        context = super(InvoiceUpdateView, self).get_context_data(**kwargs)
        if self.request.POST:
            context['receipts'] = InvoiceReceiptFormSet(self.request.POST,
                instance=self.object)
            context['items'] = InvoiceItemFormset(self.request.POST,
                instance=self.object)
        else:
            context['receipts'] = InvoiceReceiptFormSet(instance=self.object)
            context['items'] = InvoiceItemFormset(instance=self.object)
        return context

    def form_valid(self, form):
        context = self.get_context_data()
        formset = context['receipts']
        itemsformset = context['items']
        if form.is_valid() and formset.is_valid() and itemsformset.is_valid():
            form.save()
            formset.save()
            itemsformset.save()
        return super().form_valid(form)


class InvoiceDeleteView(LoginRequiredMixin, DeleteView):
    model = Invoice
    success_url = reverse_lazy('invoice-list')


class ReceiptCreateView(LoginRequiredMixin, CreateView):
    model = Receipt
    fields = ['amount_paid', 'date_paid', 'comment']
    success_url = reverse_lazy('invoice-list')

    def form_valid(self, form):
        obj = form.save(commit=False)
        invoice = Invoice.objects.get(pk=self.request.GET['invoice'])
        obj.invoice = invoice
        obj.save()
        return redirect('invoice-list')

    def get_context_data(self, **kwargs):
        context = super(ReceiptCreateView, self).get_context_data(**kwargs)
        invoice = Invoice.objects.get(pk=self.request.GET['invoice'])
        context['invoice'] = invoice
        return context


class ReceiptUpdateView(LoginRequiredMixin, UpdateView):
    model = Receipt
    fields = ['amount_paid', 'date_paid', 'comment']
    success_url = reverse_lazy('invoice-list')


class ReceiptDeleteView(LoginRequiredMixin, DeleteView):
    model = Receipt
    success_url = reverse_lazy('invoice-list')


@login_required
def bulk_invoice(request):
    return render(request, 'finance/bulk_invoice.html')
",../../Django-School-Management-System/apps/finance/views.py,views,,module,0.0,,4093,nan
views,,"from django.contrib import messages
from django.contrib.auth.decorators import login_required
from django.contrib.auth.mixins import LoginRequiredMixin
from django.shortcuts import redirect, render
from django.views.generic import DetailView, ListView, View
from apps.students.models import Student
from .forms import CreateResults, EditResults
from .models import Result


@login_required
def create_result(request):
    students = Student.objects.all()
    if request.method == 'POST':
        if 'finish' in request.POST:
            form = CreateResults(request.POST)
            if form.is_valid():
                subjects = form.cleaned_data['subjects']
                session = form.cleaned_data['session']
                term = form.cleaned_data['term']
                students = request.POST['students']
                results = []
                for student in students.split(','):
                    stu = Student.objects.get(pk=student)
                    if stu.current_class:
                        for subject in subjects:
                            check = Result.objects.filter(session=session,
                                term=term, current_class=stu.current_class,
                                subject=subject, student=stu).first()
                            if not check:
                                results.append(Result(session=session, term
                                    =term, current_class=stu.current_class,
                                    subject=subject, student=stu))
                Result.objects.bulk_create(results)
                return redirect('edit-results')
        id_list = request.POST.getlist('students')
        if id_list:
            form = CreateResults(initial={'session': request.
                current_session, 'term': request.current_term})
            studentlist = ','.join(id_list)
            return render(request, 'result/create_result_page2.html', {
                'students': studentlist, 'form': form, 'count': len(id_list)})
        else:
            messages.warning(request, 'You didnt select any student.')
    return render(request, 'result/create_result.html', {'students': students})


@login_required
def edit_results(request):
    if request.method == 'POST':
        form = EditResults(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Results successfully updated')
            return redirect('edit-results')
    else:
        results = Result.objects.filter(session=request.current_session,
            term=request.current_term)
        form = EditResults(queryset=results)
    return render(request, 'result/edit_results.html', {'formset': form})


class ResultListView(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        results = Result.objects.filter(session=request.current_session,
            term=request.current_term)
        bulk = {}
        for result in results:
            test_total = 0
            exam_total = 0
            subjects = []
            for subject in results:
                if subject.student == result.student:
                    subjects.append(subject)
                    test_total += subject.test_score
                    exam_total += subject.exam_score
            bulk[result.student.id] = {'student': result.student,
                'subjects': subjects, 'test_total': test_total,
                'exam_total': exam_total, 'total_total': test_total +
                exam_total}
        context = {'results': bulk}
        return render(request, 'result/all_results.html', context)
",../../Django-School-Management-System/apps/result/views.py,views,,module,0.0,,3621,nan
settings,"Django settings for school_app project.

Generated by 'django-admin startproject' using Django 3.0.5.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/3.0/ref/settings/","""""""
Django settings for school_app project.

Generated by 'django-admin startproject' using Django 3.0.5.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/3.0/ref/settings/
""""""
import os
BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
SECRET_KEY = '__$1ud47e&nyso5h5o3fwnqu4+hfqcply9h$k*h2s34)hn5@nc'
DEBUG = True
ALLOWED_HOSTS = []
INSTALLED_APPS = ['django.contrib.auth', 'django.contrib.contenttypes',
    'django.contrib.sessions', 'django.contrib.messages',
    'django.contrib.staticfiles', 'django.contrib.humanize',
    'widget_tweaks', 'apps.corecode', 'apps.students', 'apps.staffs',
    'apps.finance', 'apps.result']
MIDDLEWARE = ['django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'apps.corecode.middleware.SiteWideConfigs']
ROOT_URLCONF = 'school_app.urls'
TEMPLATES = [{'BACKEND': 'django.template.backends.django.DjangoTemplates',
    'DIRS': [os.path.join(BASE_DIR, 'templates')], 'APP_DIRS': True,
    'OPTIONS': {'context_processors': [
    'django.template.context_processors.debug',
    'django.template.context_processors.request',
    'django.contrib.auth.context_processors.auth',
    'django.contrib.messages.context_processors.messages',
    'apps.corecode.context_processors.site_defaults']}}]
WSGI_APPLICATION = 'school_app.wsgi.application'
DATABASES = {'default': {'ENGINE': 'django.db.backends.sqlite3', 'NAME': os
    .path.join(BASE_DIR, 'db.sqlite3')}}
AUTH_PASSWORD_VALIDATORS = [{'NAME':
    'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'
    }, {'NAME':
    'django.contrib.auth.password_validation.MinimumLengthValidator'}, {
    'NAME':
    'django.contrib.auth.password_validation.CommonPasswordValidator'}, {
    'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'}
    ]
LANGUAGE_CODE = 'en-us'
TIME_ZONE = 'UTC'
USE_I18N = True
USE_L10N = True
USE_TZ = True
DATA_UPLOAD_MAX_NUMBER_FIELDS = 10240
STATIC_URL = '/static/'
STATICFILES_DIRS = os.path.join(BASE_DIR, 'static'),
STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')
MEDIA_URL = '/media/'
LOGIN_REDIRECT_URL = '/'
LOGOUT_REDIRECT_URL = '/'
SESSION_SAVE_EVERY_REQUEST = True
SESSION_EXPIRE_AT_BROWSER_CLOSE = True
SESSION_COOKIE_AGE = 10800
LOGGING = {'version': 1, 'disable_existing_loggers': False, 'formatters': {
    'verbose': {'format': '{levelname} {asctime} {message}', 'style': '{'}},
    'handlers': {'file': {'level': 'INFO', 'class':
    'logging.handlers.TimedRotatingFileHandler', 'when': 'W6', 'interval': 
    4, 'backupCount': 3, 'encoding': 'utf8', 'filename': os.path.join(
    BASE_DIR, 'debug.log'), 'formatter': 'verbose'}}, 'loggers': {'django':
    {'handlers': ['file'], 'level': 'INFO', 'propagate': True}}}
DEFAULT_AUTO_FIELD = 'django.db.models.AutoField'
",../../Django-School-Management-System/school_app/settings.py,settings,,module,0.0,,3281,nan
views,,"import csv
from django.contrib.auth.mixins import LoginRequiredMixin
from django.contrib.messages.views import SuccessMessageMixin
from django.forms import widgets
from django.http import HttpResponse
from django.urls import reverse_lazy
from django.views.generic import DetailView, ListView, View
from django.views.generic.edit import CreateView, DeleteView, UpdateView
from apps.finance.models import Invoice
from .models import Student, StudentBulkUpload


class StudentListView(LoginRequiredMixin, ListView):
    model = Student
    template_name = 'students/student_list.html'


class StudentDetailView(LoginRequiredMixin, DetailView):
    model = Student
    template_name = 'students/student_detail.html'

    def get_context_data(self, **kwargs):
        context = super(StudentDetailView, self).get_context_data(**kwargs)
        context['payments'] = Invoice.objects.filter(student=self.object)
        return context


class StudentCreateView(LoginRequiredMixin, SuccessMessageMixin, CreateView):
    model = Student
    fields = '__all__'
    success_message = 'New student successfully added.'

    def get_form(self):
        """"""add date picker in forms""""""
        form = super(StudentCreateView, self).get_form()
        form.fields['date_of_birth'].widget = widgets.DateInput(attrs={
            'type': 'date'})
        form.fields['address'].widget = widgets.Textarea(attrs={'rows': 2})
        form.fields['others'].widget = widgets.Textarea(attrs={'rows': 2})
        return form


class StudentUpdateView(LoginRequiredMixin, SuccessMessageMixin, UpdateView):
    model = Student
    fields = '__all__'
    success_message = 'Record successfully updated.'

    def get_form(self):
        """"""add date picker in forms""""""
        form = super(StudentUpdateView, self).get_form()
        form.fields['date_of_birth'].widget = widgets.DateInput(attrs={
            'type': 'date'})
        form.fields['date_of_admission'].widget = widgets.DateInput(attrs={
            'type': 'date'})
        form.fields['address'].widget = widgets.Textarea(attrs={'rows': 2})
        form.fields['others'].widget = widgets.Textarea(attrs={'rows': 2})
        return form


class StudentDeleteView(LoginRequiredMixin, DeleteView):
    model = Student
    success_url = reverse_lazy('student-list')


class StudentBulkUploadView(LoginRequiredMixin, SuccessMessageMixin, CreateView
    ):
    model = StudentBulkUpload
    template_name = 'students/students_upload.html'
    fields = ['csv_file']
    success_url = '/student/list'
    success_message = 'Successfully uploaded students'


class DownloadCSVViewdownloadcsv(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'
            ] = 'attachment; filename=""student_template.csv""'
        writer = csv.writer(response)
        writer.writerow(['registration_number', 'surname', 'firstname',
            'other_names', 'gender', 'parent_number', 'address',
            'current_class'])
        return response
",../../Django-School-Management-System/apps/students/views.py,views,,module,0.0,,3081,nan
signals,,"import csv
import os
from io import StringIO
from django.db.models.signals import post_delete, post_save
from django.dispatch import receiver
from apps.corecode.models import StudentClass
from .models import Student, StudentBulkUpload


@receiver(post_save, sender=StudentBulkUpload)
def create_bulk_student(sender, created, instance, *args, **kwargs):
    if created:
        opened = StringIO(instance.csv_file.read().decode())
        reading = csv.DictReader(opened, delimiter=',')
        students = []
        for row in reading:
            if 'registration_number' in row and row['registration_number']:
                reg = row['registration_number']
                surname = row['surname'] if 'surname' in row and row['surname'
                    ] else ''
                firstname = row['firstname'] if 'firstname' in row and row[
                    'firstname'] else ''
                other_names = row['other_names'
                    ] if 'other_names' in row and row['other_names'] else ''
                gender = row['gender'].lower() if 'gender' in row and row[
                    'gender'] else ''
                phone = row['parent_number'] if 'parent_number' in row and row[
                    'parent_number'] else ''
                address = row['address'] if 'address' in row and row['address'
                    ] else ''
                current_class = row['current_class'
                    ] if 'current_class' in row and row['current_class'
                    ] else ''
                if current_class:
                    theclass, kind = StudentClass.objects.get_or_create(name
                        =current_class)
                check = Student.objects.filter(registration_number=reg).exists(
                    )
                if not check:
                    students.append(Student(registration_number=reg,
                        surname=surname, firstname=firstname, other_name=
                        other_names, gender=gender, current_class=theclass,
                        parent_mobile_number=phone, address=address,
                        current_status='active'))
        Student.objects.bulk_create(students)
        instance.csv_file.close()
        instance.delete()


def _delete_file(path):
    """"""Deletes file from filesystem.""""""
    if os.path.isfile(path):
        os.remove(path)


@receiver(post_delete, sender=StudentBulkUpload)
def delete_csv_file(sender, instance, *args, **kwargs):
    if instance.csv_file:
        _delete_file(instance.csv_file.path)


@receiver(post_delete, sender=Student)
def delete_passport_on_delete(sender, instance, *args, **kwargs):
    if instance.passport:
        _delete_file(instance.passport.path)
",../../Django-School-Management-System/apps/students/signals.py,signals,,module,0.0,,2715,nan
models,,"from django.db import models
from django.urls import reverse
from django.utils import timezone
from apps.corecode.models import AcademicSession, AcademicTerm, StudentClass
from apps.students.models import Student


class Invoice(models.Model):
    student = models.ForeignKey(Student, on_delete=models.CASCADE)
    session = models.ForeignKey(AcademicSession, on_delete=models.CASCADE)
    term = models.ForeignKey(AcademicTerm, on_delete=models.CASCADE)
    class_for = models.ForeignKey(StudentClass, on_delete=models.CASCADE)
    balance_from_previous_term = models.IntegerField(default=0)
    status = models.CharField(max_length=20, choices=[('active', 'Active'),
        ('closed', 'Closed')], default='active')


    class Meta:
        ordering = ['student', 'term']

    def __str__(self):
        return f'{self.student}'

    def balance(self):
        payable = self.total_amount_payable()
        paid = self.total_amount_paid()
        return payable - paid

    def amount_payable(self):
        items = InvoiceItem.objects.filter(invoice=self)
        total = 0
        for item in items:
            total += item.amount
        return total

    def total_amount_payable(self):
        return self.balance_from_previous_term + self.amount_payable()

    def total_amount_paid(self):
        receipts = Receipt.objects.filter(invoice=self)
        amount = 0
        for receipt in receipts:
            amount += receipt.amount_paid
        return amount

    def get_absolute_url(self):
        return reverse('invoice-detail', kwargs={'pk': self.pk})


class InvoiceItem(models.Model):
    invoice = models.ForeignKey(Invoice, on_delete=models.CASCADE)
    description = models.CharField(max_length=200)
    amount = models.IntegerField()


class Receipt(models.Model):
    invoice = models.ForeignKey(Invoice, on_delete=models.CASCADE)
    amount_paid = models.IntegerField()
    date_paid = models.DateField(default=timezone.now)
    comment = models.CharField(max_length=200, blank=True)

    def __str__(self):
        return f'Receipt on {self.date_paid}'
",../../Django-School-Management-System/apps/finance/models.py,models,,module,0.0,,2081,nan
create_bulk_student,,"@receiver(post_save, sender=StudentBulkUpload)
def create_bulk_student(sender, created, instance, *args, **kwargs):
    if created:
        opened = StringIO(instance.csv_file.read().decode())
        reading = csv.DictReader(opened, delimiter=',')
        students = []
        for row in reading:
            if 'registration_number' in row and row['registration_number']:
                reg = row['registration_number']
                surname = row['surname'] if 'surname' in row and row['surname'
                    ] else ''
                firstname = row['firstname'] if 'firstname' in row and row[
                    'firstname'] else ''
                other_names = row['other_names'
                    ] if 'other_names' in row and row['other_names'] else ''
                gender = row['gender'].lower() if 'gender' in row and row[
                    'gender'] else ''
                phone = row['parent_number'] if 'parent_number' in row and row[
                    'parent_number'] else ''
                address = row['address'] if 'address' in row and row['address'
                    ] else ''
                current_class = row['current_class'
                    ] if 'current_class' in row and row['current_class'
                    ] else ''
                if current_class:
                    theclass, kind = StudentClass.objects.get_or_create(name
                        =current_class)
                check = Student.objects.filter(registration_number=reg).exists(
                    )
                if not check:
                    students.append(Student(registration_number=reg,
                        surname=surname, firstname=firstname, other_name=
                        other_names, gender=gender, current_class=theclass,
                        parent_mobile_number=phone, address=address,
                        current_status='active'))
        Student.objects.bulk_create(students)
        instance.csv_file.close()
        instance.delete()
",../../Django-School-Management-System/apps/students/signals.py,signals,signals,function,,,2003,"This function is a receiver for the post_save signal of the StudentBulkUpload model. It handles the creation of multiple Student instances from a CSV file uploaded to a StudentBulkUpload instance.

Step 1: Check if a new StudentBulkUpload instance has been created.
Step 2: If a new instance was created, read the CSV file attached to this instance.
Step 3: Initialize a DictReader to read from the CSV file, using a comma as the delimiter.
Step 4: Create an empty list to hold the Student instances to be created.
Step 5: Iterate over each row in the CSV file.
Step 6: Check if the 'registration_number' column exists and has a value.
Step 7: Retrieve or set default values for all the relevant columns such as 'surname', 'firstname', 'other_names', 'gender', 'parent_number', 'address', and 'current_class'.
Step 8: If 'current_class' is provided, get or create a corresponding StudentClass instance.
Step 9: Check if a Student with the same registration number already exists.
Step 10: If the Student does not exist, append a new Student instance to the list, initialized with the retrieved or default values.
Step 11: Perform a bulk_create operation to create all the Student instances in the list at once.
Step 12: Close the CSV file attached to the StudentBulkUpload instance.
Step 13: Delete the StudentBulkUpload instance after processing the CSV file.

The function primarily affects the following variables:
- `opened`: A StringIO object holding the content of the CSV file.
- `reading`: A DictReader object used to parse the CSV file.
- `students`: A list that accumulates the Student instances to be created.
- `row`: A dictionary representing the current row being processed from the CSV.
- `reg`, `surname`, `firstname`, `other_names`, `gender`, `phone`, `address`, `current_class`: Variables holding the values from the CSV columns.
- `theclass`: The StudentClass instance corresponding to the 'current_class' value.
- `check`: A boolean indicating whether a Student with the given registration number already exists.

The purpose of the function is to automate the process of creating Student records from an uploaded CSV file, ensuring that only new, non-existing records are added to the database."
models,,"from django.core.validators import RegexValidator
from django.db import models
from django.urls import reverse
from django.utils import timezone
from apps.corecode.models import StudentClass


class Student(models.Model):
    STATUS_CHOICES = [('active', 'Active'), ('inactive', 'Inactive')]
    GENDER_CHOICES = [('male', 'Male'), ('female', 'Female')]
    current_status = models.CharField(max_length=10, choices=STATUS_CHOICES,
        default='active')
    registration_number = models.CharField(max_length=200, unique=True)
    surname = models.CharField(max_length=200)
    firstname = models.CharField(max_length=200)
    other_name = models.CharField(max_length=200, blank=True)
    gender = models.CharField(max_length=10, choices=GENDER_CHOICES,
        default='male')
    date_of_birth = models.DateField(default=timezone.now)
    current_class = models.ForeignKey(StudentClass, on_delete=models.
        SET_NULL, blank=True, null=True)
    date_of_admission = models.DateField(default=timezone.now)
    mobile_num_regex = RegexValidator(regex='^[0-9]{10,15}$', message=
        ""Entered mobile number isn't in a right format!"")
    parent_mobile_number = models.CharField(validators=[mobile_num_regex],
        max_length=13, blank=True)
    address = models.TextField(blank=True)
    others = models.TextField(blank=True)
    passport = models.ImageField(blank=True, upload_to='students/passports/')


    class Meta:
        ordering = ['surname', 'firstname', 'other_name']

    def __str__(self):
        return (
            f'{self.surname} {self.firstname} {self.other_name} ({self.registration_number})'
            )

    def get_absolute_url(self):
        return reverse('student-detail', kwargs={'pk': self.pk})


class StudentBulkUpload(models.Model):
    date_uploaded = models.DateTimeField(auto_now=True)
    csv_file = models.FileField(upload_to='students/bulkupload/')
",../../Django-School-Management-System/apps/students/models.py,models,,module,0.0,,1901,nan
urls,,"from django.urls import path
from .views import ClassCreateView, ClassDeleteView, ClassListView, ClassUpdateView, CurrentSessionAndTermView, IndexView, SessionCreateView, SessionDeleteView, SessionListView, SessionUpdateView, SiteConfigView, SubjectCreateView, SubjectDeleteView, SubjectListView, SubjectUpdateView, TermCreateView, TermDeleteView, TermListView, TermUpdateView
urlpatterns = [path('', IndexView.as_view(), name='home'), path(
    'site-config', SiteConfigView.as_view(), name='configs'), path(
    'current-session/', CurrentSessionAndTermView.as_view(), name=
    'current-session'), path('session/list/', SessionListView.as_view(),
    name='sessions'), path('session/create/', SessionCreateView.as_view(),
    name='session-create'), path('session/<int:pk>/update/',
    SessionUpdateView.as_view(), name='session-update'), path(
    'session/<int:pk>/delete/', SessionDeleteView.as_view(), name=
    'session-delete'), path('term/list/', TermListView.as_view(), name=
    'terms'), path('term/create/', TermCreateView.as_view(), name=
    'term-create'), path('term/<int:pk>/update/', TermUpdateView.as_view(),
    name='term-update'), path('term/<int:pk>/delete/', TermDeleteView.
    as_view(), name='term-delete'), path('class/list/', ClassListView.
    as_view(), name='classes'), path('class/create/', ClassCreateView.
    as_view(), name='class-create'), path('class/<int:pk>/update/',
    ClassUpdateView.as_view(), name='class-update'), path(
    'class/<int:pk>/delete/', ClassDeleteView.as_view(), name=
    'class-delete'), path('subject/list/', SubjectListView.as_view(), name=
    'subjects'), path('subject/create/', SubjectCreateView.as_view(), name=
    'subject-create'), path('subject/<int:pk>/update/', SubjectUpdateView.
    as_view(), name='subject-update'), path('subject/<int:pk>/delete/',
    SubjectDeleteView.as_view(), name='subject-delete')]
",../../Django-School-Management-System/apps/corecode/urls.py,urls,,module,0.0,,1890,nan
views,,"from django.contrib.messages.views import SuccessMessageMixin
from django.forms import widgets
from django.shortcuts import render
from django.urls import reverse_lazy
from django.views.generic import DetailView, ListView
from django.views.generic.edit import CreateView, DeleteView, UpdateView
from .models import Staff


class StaffListView(ListView):
    model = Staff


class StaffDetailView(DetailView):
    model = Staff
    template_name = 'staffs/staff_detail.html'


class StaffCreateView(SuccessMessageMixin, CreateView):
    model = Staff
    fields = '__all__'
    success_message = 'New staff successfully added'

    def get_form(self):
        """"""add date picker in forms""""""
        form = super(StaffCreateView, self).get_form()
        form.fields['date_of_birth'].widget = widgets.DateInput(attrs={
            'type': 'date'})
        form.fields['date_of_admission'].widget = widgets.DateInput(attrs={
            'type': 'date'})
        form.fields['address'].widget = widgets.Textarea(attrs={'rows': 1})
        form.fields['others'].widget = widgets.Textarea(attrs={'rows': 1})
        return form


class StaffUpdateView(SuccessMessageMixin, UpdateView):
    model = Staff
    fields = '__all__'
    success_message = 'Record successfully updated.'

    def get_form(self):
        """"""add date picker in forms""""""
        form = super(StaffUpdateView, self).get_form()
        form.fields['date_of_birth'].widget = widgets.DateInput(attrs={
            'type': 'date'})
        form.fields['date_of_admission'].widget = widgets.DateInput(attrs={
            'type': 'date'})
        form.fields['address'].widget = widgets.Textarea(attrs={'rows': 1})
        form.fields['others'].widget = widgets.Textarea(attrs={'rows': 1})
        return form


class StaffDeleteView(DeleteView):
    model = Staff
    success_url = reverse_lazy('staff-list')
",../../Django-School-Management-System/apps/staffs/views.py,views,,module,0.0,,1870,nan
create_result,,"@login_required
def create_result(request):
    students = Student.objects.all()
    if request.method == 'POST':
        if 'finish' in request.POST:
            form = CreateResults(request.POST)
            if form.is_valid():
                subjects = form.cleaned_data['subjects']
                session = form.cleaned_data['session']
                term = form.cleaned_data['term']
                students = request.POST['students']
                results = []
                for student in students.split(','):
                    stu = Student.objects.get(pk=student)
                    if stu.current_class:
                        for subject in subjects:
                            check = Result.objects.filter(session=session,
                                term=term, current_class=stu.current_class,
                                subject=subject, student=stu).first()
                            if not check:
                                results.append(Result(session=session, term
                                    =term, current_class=stu.current_class,
                                    subject=subject, student=stu))
                Result.objects.bulk_create(results)
                return redirect('edit-results')
        id_list = request.POST.getlist('students')
        if id_list:
            form = CreateResults(initial={'session': request.
                current_session, 'term': request.current_term})
            studentlist = ','.join(id_list)
            return render(request, 'result/create_result_page2.html', {
                'students': studentlist, 'form': form, 'count': len(id_list)})
        else:
            messages.warning(request, 'You didnt select any student.')
    return render(request, 'result/create_result.html', {'students': students})
",../../Django-School-Management-System/apps/result/views.py,views,views,function,,,1812,"This function handles the creation of student results within a web application, utilizing the Django framework.

The function performs the following steps:
1. Fetches all Student objects from the database.
2. Checks if the request method is POST, indicating form submission.
3. If the 'finish' button is pressed in the form, it processes the form submission:
    a. Creates a form instance with the POST data.
    b. Validates the form.
    c. Extracts the selected subjects, session, and term from the cleaned form data.
    d. Retrieves the list of student IDs from the POST data.
    e. Initializes an empty list to hold Result objects.
    f. For each student ID, retrieves the corresponding Student object.
    g. Checks if the student has a current class assigned.
    h. If so, iterates over the selected subjects and checks whether a result already exists for the given session, term, subject, and student.
    i. If no result exists, creates a new Result object and appends it to the results list.
    j. Performs a bulk creation of Result objects in the database.
    k. Redirects to the 'edit-results' page after successful creation.
4. If the 'finish' button is not pressed, it checks for a list of selected student IDs:
    a. If student IDs are selected, initializes the form with the current session and term.
    b. Joins the list of student IDs into a comma-separated string.
    c. Renders a second page of result creation with the selected students, the form, and the count of selected students.
5. If no students are selected, displays a warning message.
6. If the request method is not POST, renders the result creation page with the list of all students.

The function uses the following variables:
- students: A QuerySet containing all Student objects.
- form: An instance of the CreateResults form class, populated with POST data when submitted.
- subjects, session, term: Variables holding the cleaned data from the form.
- students: A string containing the selected student IDs from the POST data.
- results: A list to store new Result objects for bulk creation.
- studentlist: A comma-separated string of student IDs for the second page rendering.
- id_list: A list of selected student IDs from the POST data.
- stu: A Student object used in the loop to create results.

The function is decorated with @login_required to ensure that only authenticated users can access it."
Student,,"class Student(models.Model):
    STATUS_CHOICES = [('active', 'Active'), ('inactive', 'Inactive')]
    GENDER_CHOICES = [('male', 'Male'), ('female', 'Female')]
    current_status = models.CharField(max_length=10, choices=STATUS_CHOICES,
        default='active')
    registration_number = models.CharField(max_length=200, unique=True)
    surname = models.CharField(max_length=200)
    firstname = models.CharField(max_length=200)
    other_name = models.CharField(max_length=200, blank=True)
    gender = models.CharField(max_length=10, choices=GENDER_CHOICES,
        default='male')
    date_of_birth = models.DateField(default=timezone.now)
    current_class = models.ForeignKey(StudentClass, on_delete=models.
        SET_NULL, blank=True, null=True)
    date_of_admission = models.DateField(default=timezone.now)
    mobile_num_regex = RegexValidator(regex='^[0-9]{10,15}$', message=
        ""Entered mobile number isn't in a right format!"")
    parent_mobile_number = models.CharField(validators=[mobile_num_regex],
        max_length=13, blank=True)
    address = models.TextField(blank=True)
    others = models.TextField(blank=True)
    passport = models.ImageField(blank=True, upload_to='students/passports/')


    class Meta:
        ordering = ['surname', 'firstname', 'other_name']

    def __str__(self):
        return (
            f'{self.surname} {self.firstname} {self.other_name} ({self.registration_number})'
            )

    def get_absolute_url(self):
        return reverse('student-detail', kwargs={'pk': self.pk})
",../../Django-School-Management-System/apps/students/models.py,models,models,class,,,1545,"Returns the absolute URL for the Student instance.

This method is used to obtain the canonical URL for a Student object to be used in templates or redirects.
It calls Django's 'reverse' function to reverse-resolve the URL pattern named 'student-detail'
using the primary key ('pk') of the current Student instance.

:return: A string representing the absolute URL pointing to the specific student detail page.
"""""""
Invoice,,"class Invoice(models.Model):
    student = models.ForeignKey(Student, on_delete=models.CASCADE)
    session = models.ForeignKey(AcademicSession, on_delete=models.CASCADE)
    term = models.ForeignKey(AcademicTerm, on_delete=models.CASCADE)
    class_for = models.ForeignKey(StudentClass, on_delete=models.CASCADE)
    balance_from_previous_term = models.IntegerField(default=0)
    status = models.CharField(max_length=20, choices=[('active', 'Active'),
        ('closed', 'Closed')], default='active')


    class Meta:
        ordering = ['student', 'term']

    def __str__(self):
        return f'{self.student}'

    def balance(self):
        payable = self.total_amount_payable()
        paid = self.total_amount_paid()
        return payable - paid

    def amount_payable(self):
        items = InvoiceItem.objects.filter(invoice=self)
        total = 0
        for item in items:
            total += item.amount
        return total

    def total_amount_payable(self):
        return self.balance_from_previous_term + self.amount_payable()

    def total_amount_paid(self):
        receipts = Receipt.objects.filter(invoice=self)
        amount = 0
        for receipt in receipts:
            amount += receipt.amount_paid
        return amount

    def get_absolute_url(self):
        return reverse('invoice-detail', kwargs={'pk': self.pk})
",../../Django-School-Management-System/apps/finance/models.py,models,models,class,,,1356,"Calculates the current balance on the invoice, taking into account the total amount payable and the total amount paid.

This function performs several steps to calculate the balance:
1. Calls `total_amount_payable` to calculate the total amount that should be paid. This includes the balance from the previous term and the sum of amounts from all related `InvoiceItem` objects.
2. Calls `total_amount_paid` to calculate the total amount that has already been paid. This is the sum of the `amount_paid` field from all related `Receipt` objects.
3. Subtracts the total amount paid from the total amount payable to arrive at the current balance.

The function affects the following variables:
- `payable`: Holds the result from `total_amount_payable`, representing the total amount that needs to be paid.
- `paid`: Holds the result from `total_amount_paid`, representing the total amount that has already been paid.

Returns:
    The balance of the invoice, which is the difference between what is payable and what has been paid."
forms,,"from django import forms
from django.forms import ModelForm, modelformset_factory
from .models import AcademicSession, AcademicTerm, SiteConfig, StudentClass, Subject
SiteConfigForm = modelformset_factory(SiteConfig, fields=('key', 'value'),
    extra=0)


class AcademicSessionForm(ModelForm):
    prefix = 'Academic Session'


    class Meta:
        model = AcademicSession
        fields = ['name', 'current']


class AcademicTermForm(ModelForm):
    prefix = 'Academic Term'


    class Meta:
        model = AcademicTerm
        fields = ['name', 'current']


class SubjectForm(ModelForm):
    prefix = 'Subject'


    class Meta:
        model = Subject
        fields = ['name']


class StudentClassForm(ModelForm):
    prefix = 'Class'


    class Meta:
        model = StudentClass
        fields = ['name']


class CurrentSessionForm(forms.Form):
    current_session = forms.ModelChoiceField(queryset=AcademicSession.
        objects.all(), help_text=
        'Click <a href=""/session/create/?next=current-session/"">here</a> to add new session'
        )
    current_term = forms.ModelChoiceField(queryset=AcademicTerm.objects.all
        (), help_text=
        'Click <a href=""/term/create/?next=current-session/"">here</a> to add new term'
        )
",../../Django-School-Management-System/apps/corecode/forms.py,forms,,module,0.0,,1262,nan
models,,"from django.core.validators import RegexValidator
from django.db import models
from django.urls import reverse
from django.utils import timezone


class Staff(models.Model):
    STATUS = [('active', 'Active'), ('inactive', 'Inactive')]
    GENDER = [('male', 'Male'), ('female', 'Female')]
    current_status = models.CharField(max_length=10, choices=STATUS,
        default='active')
    surname = models.CharField(max_length=200)
    firstname = models.CharField(max_length=200)
    other_name = models.CharField(max_length=200, blank=True)
    gender = models.CharField(max_length=10, choices=GENDER, default='male')
    date_of_birth = models.DateField(default=timezone.now)
    date_of_admission = models.DateField(default=timezone.now)
    mobile_num_regex = RegexValidator(regex='^[0-9]{10,15}$', message=
        ""Entered mobile number isn't in a right format!"")
    mobile_number = models.CharField(validators=[mobile_num_regex],
        max_length=13, blank=True)
    address = models.TextField(blank=True)
    others = models.TextField(blank=True)

    def __str__(self):
        return f'{self.surname} {self.firstname} {self.other_name}'

    def get_absolute_url(self):
        return reverse('staff-detail', kwargs={'pk': self.pk})
",../../Django-School-Management-System/apps/staffs/models.py,models,,module,0.0,,1247,nan
models,,"from django.db import models


class SiteConfig(models.Model):
    """"""Site Configurations""""""
    key = models.SlugField()
    value = models.CharField(max_length=200)

    def __str__(self):
        return self.key


class AcademicSession(models.Model):
    """"""Academic Session""""""
    name = models.CharField(max_length=200, unique=True)
    current = models.BooleanField(default=True)


    class Meta:
        ordering = ['-name']

    def __str__(self):
        return self.name


class AcademicTerm(models.Model):
    """"""Academic Term""""""
    name = models.CharField(max_length=20, unique=True)
    current = models.BooleanField(default=True)


    class Meta:
        ordering = ['name']

    def __str__(self):
        return self.name


class Subject(models.Model):
    """"""Subject""""""
    name = models.CharField(max_length=200, unique=True)


    class Meta:
        ordering = ['name']

    def __str__(self):
        return self.name


class StudentClass(models.Model):
    name = models.CharField(max_length=200, unique=True)


    class Meta:
        verbose_name = 'Class'
        verbose_name_plural = 'Classes'
        ordering = ['name']

    def __str__(self):
        return self.name
",../../Django-School-Management-System/apps/corecode/models.py,models,,module,0.0,,1201,nan
CurrentSessionAndTermView,Current SEssion and Term,"class CurrentSessionAndTermView(LoginRequiredMixin, View):
    """"""Current SEssion and Term""""""
    form_class = CurrentSessionForm
    template_name = 'corecode/current_session.html'

    def get(self, request, *args, **kwargs):
        form = self.form_class(initial={'current_session': AcademicSession.
            objects.get(current=True), 'current_term': AcademicTerm.objects
            .get(current=True)})
        return render(request, self.template_name, {'form': form})

    def post(self, request, *args, **kwargs):
        form = self.form_class(request.POST, initial={'current_session':
            AcademicSession.objects.get(current=True), 'current_term':
            AcademicTerm.objects.get(current=True)})
        if form.is_valid():
            session = form.cleaned_data['current_session']
            term = form.cleaned_data['current_term']
            AcademicSession.objects.filter(name=session).update(current=True)
            AcademicSession.objects.exclude(name=session).update(current=False)
            AcademicTerm.objects.filter(name=term).update(current=True)
        return render(request, self.template_name, {'form': form})
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,1161,"Handles GET and POST requests for setting the current academic session and term.

- get(self, request, *args, **kwargs): Handles the GET request by creating a form with initial data set to the current academic session and term from the database. It then renders the 'corecode/current_session.html' template with the form context.

- post(self, request, *args, **kwargs): Handles the POST request by instantiating the form with the submitted data and the initial current session and term. If the form is valid, it proceeds to update the AcademicSession and AcademicTerm objects, setting the chosen session and term as the current ones and unsetting the previous ones. Finally, it re-renders the 'corecode/current_session.html' template with the context containing the form (with the potentially updated current session and term)."
urls,"newapp URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/3.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))","""""""newapp URL Configuration

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/3.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
""""""
from django.conf import settings
from django.conf.urls.static import static
from django.urls import include, path
urlpatterns = [path('accounts/', include('django.contrib.auth.urls')), path
    ('', include('apps.corecode.urls')), path('student/', include(
    'apps.students.urls')), path('staff/', include('apps.staffs.urls')),
    path('finance/', include('apps.finance.urls')), path('result/', include
    ('apps.result.urls'))] + static(settings.MEDIA_URL, document_root=
    settings.MEDIA_ROOT)
",../../Django-School-Management-System/school_app/urls.py,urls,,module,0.0,,1132,nan
Staff,,"class Staff(models.Model):
    STATUS = [('active', 'Active'), ('inactive', 'Inactive')]
    GENDER = [('male', 'Male'), ('female', 'Female')]
    current_status = models.CharField(max_length=10, choices=STATUS,
        default='active')
    surname = models.CharField(max_length=200)
    firstname = models.CharField(max_length=200)
    other_name = models.CharField(max_length=200, blank=True)
    gender = models.CharField(max_length=10, choices=GENDER, default='male')
    date_of_birth = models.DateField(default=timezone.now)
    date_of_admission = models.DateField(default=timezone.now)
    mobile_num_regex = RegexValidator(regex='^[0-9]{10,15}$', message=
        ""Entered mobile number isn't in a right format!"")
    mobile_number = models.CharField(validators=[mobile_num_regex],
        max_length=13, blank=True)
    address = models.TextField(blank=True)
    others = models.TextField(blank=True)

    def __str__(self):
        return f'{self.surname} {self.firstname} {self.other_name}'

    def get_absolute_url(self):
        return reverse('staff-detail', kwargs={'pk': self.pk})
",../../Django-School-Management-System/apps/staffs/models.py,models,models,class,,,1100,"Generate the absolute URL for a Staff instance.

This method uses the 'reverse' function to construct the URL for the staff-detail view.
It relies on the primary key (pk) of the Staff instance to create a unique URL for each staff member.

Returns:
    str: The absolute URL pointing to the detail view of this specific staff member.

Variables affected:
    self: The Staff instance for which the URL is being generated."
InvoiceUpdateView,,"class InvoiceUpdateView(LoginRequiredMixin, UpdateView):
    model = Invoice
    fields = ['student', 'session', 'term', 'class_for',
        'balance_from_previous_term']

    def get_context_data(self, **kwargs):
        context = super(InvoiceUpdateView, self).get_context_data(**kwargs)
        if self.request.POST:
            context['receipts'] = InvoiceReceiptFormSet(self.request.POST,
                instance=self.object)
            context['items'] = InvoiceItemFormset(self.request.POST,
                instance=self.object)
        else:
            context['receipts'] = InvoiceReceiptFormSet(instance=self.object)
            context['items'] = InvoiceItemFormset(instance=self.object)
        return context

    def form_valid(self, form):
        context = self.get_context_data()
        formset = context['receipts']
        itemsformset = context['items']
        if form.is_valid() and formset.is_valid() and itemsformset.is_valid():
            form.save()
            formset.save()
            itemsformset.save()
        return super().form_valid(form)
",../../Django-School-Management-System/apps/finance/views.py,views,views,class,,,1083,"This class-based view, `InvoiceUpdateView`, inherits from `LoginRequiredMixin` and `UpdateView`, 
indicating it is a protected view for updating existing Invoice entries, and requires the user to be logged in.

The `get_context_data` method is overridden to include additional formsets in the context:
- If the request method is POST, meaning form data has been submitted, it initializes the formsets 
  (`InvoiceReceiptFormSet` and `InvoiceItemFormset`) with the posted data and associates them with 
  the current Invoice instance (`self.object`).
- If the request is not POST (likely GET), it initializes the formsets without any POST data, again 
  associating them with the current Invoice instance.
This allows the use of nested formsets for editing related objects (receipts and items) in the same view as the main Invoice object.

The `form_valid` method is overridden to perform custom validation logic:
- It retrieves the formsets from the context.
- It checks if the main form (`form`), the `InvoiceReceiptFormSet` (`formset`), and the `InvoiceItemFormset` (`itemsformset`) are all valid.
- If all forms are valid, it saves the changes to the Invoice object, the associated receipts, and the items.
- It then calls the parent class's `form_valid` method to continue with the usual form handling, such as redirecting to a success URL.

The view uses the `Invoice` model and specifies the fields to be displayed and edited in the form. These fields include 'student', 'session', 'term', 'class_for', and 'balance_from_previous_term'.

Overall, this view facilitates the editing of an Invoice and its related receipts and items in a single page, handling both the display and valid submission of these forms."
models,,"from django.db import models
from apps.corecode.models import AcademicSession, AcademicTerm, StudentClass, Subject
from apps.students.models import Student
from .utils import score_grade


class Result(models.Model):
    student = models.ForeignKey(Student, on_delete=models.CASCADE)
    session = models.ForeignKey(AcademicSession, on_delete=models.CASCADE)
    term = models.ForeignKey(AcademicTerm, on_delete=models.CASCADE)
    current_class = models.ForeignKey(StudentClass, on_delete=models.CASCADE)
    subject = models.ForeignKey(Subject, on_delete=models.CASCADE)
    test_score = models.IntegerField(default=0)
    exam_score = models.IntegerField(default=0)


    class Meta:
        ordering = ['subject']

    def __str__(self):
        return f'{self.student} {self.session} {self.term} {self.subject}'

    def total_score(self):
        return self.test_score + self.exam_score

    def grade(self):
        return score_grade(self.total_score())
",../../Django-School-Management-System/apps/result/models.py,models,,module,0.0,,963,nan
ResultListView,,"class ResultListView(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        results = Result.objects.filter(session=request.current_session,
            term=request.current_term)
        bulk = {}
        for result in results:
            test_total = 0
            exam_total = 0
            subjects = []
            for subject in results:
                if subject.student == result.student:
                    subjects.append(subject)
                    test_total += subject.test_score
                    exam_total += subject.exam_score
            bulk[result.student.id] = {'student': result.student,
                'subjects': subjects, 'test_total': test_total,
                'exam_total': exam_total, 'total_total': test_total +
                exam_total}
        context = {'results': bulk}
        return render(request, 'result/all_results.html', context)
",../../Django-School-Management-System/apps/result/views.py,views,views,class,,,907,"Fetches and aggregates the results for students in a given session and term.

This method retrieves all Result objects that match the current session and term from the request. 
It then aggregates the results by student, calculating the total test and exam scores for each student, 
and including all the subjects associated with that student.

The process is as follows:
1. Filter the Result objects using the current session and term from the request.
2. Initialize an empty dictionary `bulk` to store the aggregated results.
3. Iterate over each result in the filtered results set.
4. For each student, create a list of subjects and initialize their test and exam totals to zero.
5. Iterate over the results again and for each subject that matches the current student, append it to the subjects list.
   Also, increment the student's test_total and exam_total by the subject's test and exam scores.
6. Store the student's aggregated data in the `bulk` dictionary, keyed by the student's id. This data includes the student object, 
   list of subjects, total test score, total exam score, and the grand total of test and exam scores.
7. Create a context dictionary with the key 'results' pointing to the `bulk` dictionary.
8. Render the 'result/all_results.html' template with the context containing the aggregated results.

Note:
- The Result object is expected to have attributes: student, test_score, exam_score, session, and term.
- The function affects the `bulk` and `context` variables."
InvoiceCreateView,,"class InvoiceCreateView(LoginRequiredMixin, CreateView):
    model = Invoice
    fields = '__all__'
    success_url = '/finance/list'

    def get_context_data(self, **kwargs):
        context = super(InvoiceCreateView, self).get_context_data(**kwargs)
        if self.request.POST:
            context['items'] = InvoiceItemFormset(self.request.POST, prefix
                ='invoiceitem_set')
        else:
            context['items'] = InvoiceItemFormset(prefix='invoiceitem_set')
        return context

    def form_valid(self, form):
        context = self.get_context_data()
        formset = context['items']
        self.object = form.save()
        if self.object.id != None:
            if form.is_valid() and formset.is_valid():
                formset.instance = self.object
                formset.save()
        return super().form_valid(form)
",../../Django-School-Management-System/apps/finance/views.py,views,views,class,,,860,"This class-based view `InvoiceCreateView` extends Django's `CreateView` to provide a custom view for creating an invoice. The class contains two methods, `get_context_data` and `form_valid`, which are overridden to customize the default behavior of the CreateView.

`get_context_data`:
-------------------
- This method enhances the context data with invoice item formsets before rendering the template.
- It first calls the parent class's `get_context_data` to obtain the default context data.
- It checks if the request is a POST request to determine whether the form is being submitted.
- If it is a POST request, it initializes the invoice item formset with the POST data and a specific prefix 'invoiceitem_set'.
- If it is not a POST request (e.g., when the form is first displayed), it initializes an empty invoice item formset with the same prefix.
- The initialized formset (either populated with POST data or empty) is then added to the context dictionary under the key 'items'.
- The updated context, now containing the formset, is returned to be used when rendering the template.

`form_valid`:
--------------
- This method handles the logic that occurs when a valid form is submitted.
- It first retrieves the context data (which includes the invoice item formset) by calling `get_context_data`.
- The formset is extracted from the context dictionary using the key 'items'.
- It then saves the main form (`Invoice`) and assigns the resulting object to `self.object`.
- If the newly created `Invoice` object has a valid ID (indicating it was saved successfully), it proceeds to validate the formset.
- It checks if both the main form and the formset are valid.
- If they are valid, it sets the instance of the formset to the created `Invoice` object, ensuring that the invoice items are associated with the correct invoice.
- It then saves the formset, which saves all the associated invoice items to the database.
- Finally, the method calls the parent class's `form_valid` method to complete the processing and redirect to the `success_url`.

The `InvoiceCreateView` class is designed to be used with the `Invoice` model and accepts all fields from the model (`fields = '__all__'`). Upon successful creation of an invoice, it redirects users to the URL specified by `success_url`. It requires users to be logged in, as it inherits from `LoginRequiredMixin`."
urls,,"from django.urls import path
from .views import InvoiceCreateView, InvoiceDeleteView, InvoiceDetailView, InvoiceListView, InvoiceUpdateView, ReceiptCreateView, ReceiptUpdateView, bulk_invoice
urlpatterns = [path('list/', InvoiceListView.as_view(), name='invoice-list'
    ), path('create/', InvoiceCreateView.as_view(), name='invoice-create'),
    path('<int:pk>/detail/', InvoiceDetailView.as_view(), name=
    'invoice-detail'), path('<int:pk>/update/', InvoiceUpdateView.as_view(),
    name='invoice-update'), path('<int:pk>/delete/', InvoiceDeleteView.
    as_view(), name='invoice-delete'), path('receipt/create',
    ReceiptCreateView.as_view(), name='receipt-create'), path(
    'receipt/<int:pk>/update/', ReceiptUpdateView.as_view(), name=
    'receipt-update'), path('bulk-invoice/', bulk_invoice, name='bulk-invoice')
    ]
",../../Django-School-Management-System/apps/finance/urls.py,urls,,module,0.0,,835,nan
Result,,"class Result(models.Model):
    student = models.ForeignKey(Student, on_delete=models.CASCADE)
    session = models.ForeignKey(AcademicSession, on_delete=models.CASCADE)
    term = models.ForeignKey(AcademicTerm, on_delete=models.CASCADE)
    current_class = models.ForeignKey(StudentClass, on_delete=models.CASCADE)
    subject = models.ForeignKey(Subject, on_delete=models.CASCADE)
    test_score = models.IntegerField(default=0)
    exam_score = models.IntegerField(default=0)


    class Meta:
        ordering = ['subject']

    def __str__(self):
        return f'{self.student} {self.session} {self.term} {self.subject}'

    def total_score(self):
        return self.test_score + self.exam_score

    def grade(self):
        return score_grade(self.total_score())
",../../Django-School-Management-System/apps/result/models.py,models,models,class,,,774,"Calculates the total score for a student's result.

The function aggregates the student's test and exam scores by summing them up to get a total score. It takes no arguments and returns the total numerical score. This function directly references the instance variables `test_score` and `exam_score`.

:return: Returns the sum of `test_score` and `exam_score` representing the total score.
:rtype: int"
urls,,"from django.urls import path
from .views import DownloadCSVViewdownloadcsv, StudentBulkUploadView, StudentCreateView, StudentDeleteView, StudentDetailView, StudentListView, StudentUpdateView
urlpatterns = [path('list', StudentListView.as_view(), name='student-list'),
    path('<int:pk>/', StudentDetailView.as_view(), name='student-detail'),
    path('create/', StudentCreateView.as_view(), name='student-create'),
    path('<int:pk>/update/', StudentUpdateView.as_view(), name=
    'student-update'), path('delete/<int:pk>/', StudentDeleteView.as_view(),
    name='student-delete'), path('upload/', StudentBulkUploadView.as_view(),
    name='student-upload'), path('download-csv/',
    DownloadCSVViewdownloadcsv.as_view(), name='download-csv')]
",../../Django-School-Management-System/apps/students/urls.py,urls,,module,0.0,,748,nan
SiteConfigView,Site Config View,"class SiteConfigView(LoginRequiredMixin, View):
    """"""Site Config View""""""
    form_class = SiteConfigForm
    template_name = 'corecode/siteconfig.html'

    def get(self, request, *args, **kwargs):
        formset = self.form_class(queryset=SiteConfig.objects.all())
        context = {'formset': formset}
        return render(request, self.template_name, context)

    def post(self, request, *args, **kwargs):
        formset = self.form_class(request.POST)
        if formset.is_valid():
            formset.save()
            messages.success(request, 'Configurations successfully updated')
        context = {'formset': formset, 'title': 'Configuration'}
        return render(request, self.template_name, context)
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,723,"Handles GET and POST requests for updating site configurations using a formset.

The `get` method creates a formset instance for all `SiteConfig` objects and passes it to the template
for rendering. It essentially prepares and displays the site configuration form to the user.

The `post` method handles the submission of the formset. It initializes the formset with the POST data
and checks if it's valid. If the formset is valid, it saves the changes to the `SiteConfig` objects,
displays a success message, and re-renders the page with the updated configurations. If the formset
is not valid, it simply re-renders the page with the existing formset data, showing any validation errors.

Attributes:
    form_class (Form): The form class used to create the formset for site configurations.
    template_name (str): The path to the HTML template used to render the site configuration page.

Methods:
    get(self, request, *args, **kwargs):
        Prepares and displays the site configuration form to the user.

    post(self, request, *args, **kwargs):
        Processes the submitted site configuration formset, validates it, saves changes if valid,
        and re-renders the configuration page with a success message or validation errors."
SessionUpdateView,,"class SessionUpdateView(LoginRequiredMixin, SuccessMessageMixin, UpdateView):
    model = AcademicSession
    form_class = AcademicSessionForm
    success_url = reverse_lazy('sessions')
    success_message = 'Session successfully updated.'
    template_name = 'corecode/mgt_form.html'

    def form_valid(self, form):
        obj = self.object
        if obj.current == False:
            terms = AcademicSession.objects.filter(current=True).exclude(name
                =obj.name).exists()
            if not terms:
                messages.warning(self.request,
                    'You must set a session to current.')
                return redirect('session-list')
        return super().form_valid(form)
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,710,"This method is an overridden version of the `form_valid` method from the `UpdateView` class,
which is called when a valid form is posted. It serves to handle additional validation and
actions that need to be taken before the object is updated in the database.

Steps and purpose of the function:
1. The method first retrieves the object that is currently being updated and stores it in the local variable `obj`.
2. It then checks if the `current` attribute of `obj` is set to `False`.
3. If `current` is `False`, the method queries the database for any other `AcademicSession` objects that have
   the `current` attribute set to `True` while excluding the session with the same name as the current object.
4. The existence of such a session is checked using the `exists()` method on the queryset.
5. If no such sessions exist (which means there would be no current session if this one is updated to not be current),
   the method sends a warning message to the user indicating that at least one session must be set to current.
6. It then redirects the user back to the session list page (`'session-list'`) without updating the object.
7. If the `current` attribute is `True` or if there are other sessions that are currently set to `True`, the
   method calls the superclass's `form_valid` method to proceed with the normal object update process.

Variables affected:
- `obj`: The object instance being updated.
- `messages`: Used to add a warning message to the request context if needed.
- `self.object`: The instance of the object that the view is currently working with.

:return: If validation fails due to no current session being set, a redirect response is returned.
         Otherwise, the response from the superclass's `form_valid` method is returned, which
         typically updates the object and redirects to the success URL."
signals,,"from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import AcademicSession, AcademicTerm


@receiver(post_save, sender=AcademicSession)
def after_saving_session(sender, created, instance, *args, **kwargs):
    """"""Change all academic sessions to false if this is true""""""
    if instance.current is True:
        AcademicSession.objects.exclude(pk=instance.id).update(current=False)


@receiver(post_save, sender=AcademicTerm)
def after_saving_term(sender, created, instance, *args, **kwargs):
    """"""Change all academic terms to false if this is true.""""""
    if instance.current is True:
        AcademicTerm.objects.exclude(pk=instance.id).update(current=False)
",../../Django-School-Management-System/apps/corecode/signals.py,signals,,module,0.0,,707,nan
SessionDeleteView,,"class SessionDeleteView(LoginRequiredMixin, DeleteView):
    model = AcademicSession
    success_url = reverse_lazy('sessions')
    template_name = 'corecode/core_confirm_delete.html'
    success_message = (
        'The session {} has been deleted with all its attached content')

    def delete(self, request, *args, **kwargs):
        obj = self.get_object()
        if obj.current == True:
            messages.warning(request,
                'Cannot delete session as it is set to current')
            return redirect('sessions')
        messages.success(self.request, self.success_message.format(obj.name))
        return super(SessionDeleteView, self).delete(request, *args, **kwargs)
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,694,"Deletes an instance of AcademicSession and redirects to a success URL.

This method overrides the `delete` method from the `DeleteView` class. When a delete request is made, the following steps are performed:

1. Retrieves the AcademicSession object to be deleted using the `get_object()` method.
2. Checks if the session object's 'current' attribute is set to True, indicating it is the current session.
    - If it is the current session, a warning message is generated and the user is redirected to the 'sessions' URL without deleting the object.
3. If the session is not current, a success message is generated, which includes the name of the session being deleted.
4. Calls the parent class's `delete` method to perform the actual deletion of the object.
5. Redirects to the 'sessions' URL as defined in the `success_url` attribute of the class.

Variables affected:
- `obj`: The AcademicSession object that is targeted for deletion.
- `request`: The HTTP request object that carries the delete request.
- `messages`: The messages framework is used to provide feedback to the user.
- `success_url`: The URL to redirect to after the object is successfully deleted.
- `success_message`: The message displayed to the user upon successful deletion.

The function affects the state of the database by deleting an AcademicSession object, provided it is not set as the current session."
TermUpdateView,,"class TermUpdateView(LoginRequiredMixin, SuccessMessageMixin, UpdateView):
    model = AcademicTerm
    form_class = AcademicTermForm
    success_url = reverse_lazy('terms')
    success_message = 'Term successfully updated.'
    template_name = 'corecode/mgt_form.html'

    def form_valid(self, form):
        obj = self.object
        if obj.current == False:
            terms = AcademicTerm.objects.filter(current=True).exclude(name=
                obj.name).exists()
            if not terms:
                messages.warning(self.request,
                    'You must set a term to current.')
                return redirect('term')
        return super().form_valid(form)
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,681,"Validates the form used in the TermUpdateView to ensure business logic compliance.

When the 'form_valid' method is called, it performs the following steps:

1. Retrieves the current object being updated, referred to as 'obj'.
2. Checks if the 'current' attribute of 'obj' is set to False. If so, it proceeds
   to the next step; otherwise, it simply calls the superclass's form_valid method
   to handle the form submission.
3. Queries the AcademicTerm model to check if there are any other terms marked
   as 'current' while excluding the term represented by 'obj'.
4. If no other terms are set to 'current', it displays a warning message to the user
   indicating that at least one term must be set to current.
5. Redirects the user back to the 'term' URL if the warning condition is met.
6. If another term is already set to current, it allows the form submission to
   continue normally by calling the superclass's form_valid method.

This method affects the following variables:
- 'obj': the instance of AcademicTerm being updated.
- 'terms': a boolean indicating the existence of other 'current' terms in the database.
- 'success_message': a message displayed upon successful form submission.

The purpose of this method is to ensure that there cannot be a situation where
no academic terms are set as current within the system. It enforces the business
rule that at least one term must always be current.

Returns:
    - A redirect to the 'term' URL if the warning condition is met.
    - A call to the superclass's form_valid method for normal form handling otherwise."
TermDeleteView,,"class TermDeleteView(LoginRequiredMixin, DeleteView):
    model = AcademicTerm
    success_url = reverse_lazy('terms')
    template_name = 'corecode/core_confirm_delete.html'
    success_message = (
        'The term {} has been deleted with all its attached content')

    def delete(self, request, *args, **kwargs):
        obj = self.get_object()
        if obj.current == True:
            messages.warning(request,
                'Cannot delete term as it is set to current')
            return redirect('terms')
        messages.success(self.request, self.success_message.format(obj.name))
        return super(TermDeleteView, self).delete(request, *args, **kwargs)
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,673,"Deletes an object of AcademicTerm and redirects to the term list page.

This method overrides the `delete` method of the DeleteView class to provide custom
logic before deleting an AcademicTerm object.

Steps:
1. Retrieve the object to be deleted using `self.get_object()`.
2. Check if the object's `current` attribute is True, indicating it is the current term.
3. If it is the current term, display a warning message and redirect to the 'terms' page without deleting.
4. If it is not the current term, display a success message indicating the term and its content have been deleted.
5. Call the parent class's delete method to perform the actual deletion process.

Variables affected:
- `obj`: The AcademicTerm object that is retrieved and checked.
- `self.request`: The request object where the success or warning messages are added.

Purpose:
The purpose of this function is to prevent the deletion of the current AcademicTerm and to ensure that a user
receives appropriate feedback when attempting to delete an AcademicTerm. If deletion is allowed, it proceeds with the
standard deletion process and redirects the user to the success URL with a confirmation message."
StudentUpdateView,,"class StudentUpdateView(LoginRequiredMixin, SuccessMessageMixin, UpdateView):
    model = Student
    fields = '__all__'
    success_message = 'Record successfully updated.'

    def get_form(self):
        """"""add date picker in forms""""""
        form = super(StudentUpdateView, self).get_form()
        form.fields['date_of_birth'].widget = widgets.DateInput(attrs={
            'type': 'date'})
        form.fields['date_of_admission'].widget = widgets.DateInput(attrs={
            'type': 'date'})
        form.fields['address'].widget = widgets.Textarea(attrs={'rows': 2})
        form.fields['others'].widget = widgets.Textarea(attrs={'rows': 2})
        return form
",../../Django-School-Management-System/apps/students/views.py,views,views,class,,,672,"Fetches and modifies the default form for the StudentUpdateView.

This method overrides the default get_form method to customize form widgets.
It sets custom widgets with specific attributes for the date_of_birth and date_of_admission
fields to use a date picker, and for the address and others fields to use a textarea with a set
number of rows.

Steps:
1. Calls the parent class's get_form method to retrieve the default form.
2. Modifies the form's date_of_birth field to use a DateInput widget with the 'type' attribute set to 'date'.
3. Modifies the form's date_of_admission field in the same manner as the date_of_birth field.
4. Changes the widget for the address field to be a Textarea with the 'rows' attribute set to 2.
5. Does the same for the others field, setting its widget to a Textarea with the 'rows' attribute set to 2.
6. Returns the modified form.

The purpose of this method is to enhance the user interface for date selection and text input,
making it more user-friendly and visually consistent.

Variables affected:
- 'date_of_birth' widget: Set to use a DateInput widget for date selection.
- 'date_of_admission' widget: Also set to use a DateInput widget for date selection.
- 'address' widget: Set to use a Textarea widget with a specific number of rows for text input.
- 'others' widget: Set to use a Textarea widget with a specific number of rows for text input."
ReceiptCreateView,,"class ReceiptCreateView(LoginRequiredMixin, CreateView):
    model = Receipt
    fields = ['amount_paid', 'date_paid', 'comment']
    success_url = reverse_lazy('invoice-list')

    def form_valid(self, form):
        obj = form.save(commit=False)
        invoice = Invoice.objects.get(pk=self.request.GET['invoice'])
        obj.invoice = invoice
        obj.save()
        return redirect('invoice-list')

    def get_context_data(self, **kwargs):
        context = super(ReceiptCreateView, self).get_context_data(**kwargs)
        invoice = Invoice.objects.get(pk=self.request.GET['invoice'])
        context['invoice'] = invoice
        return context
",../../Django-School-Management-System/apps/finance/views.py,views,views,class,,,656,"A class-based view for creating Receipt instances associated with an Invoice.

Methods:
    form_valid(form):
        Processes the valid form submission for creating a Receipt.
        
        1. Saves the form to a Receipt object with `commit=False` to not yet save it to the database.
        2. Retrieves the associated Invoice instance using the primary key provided in the request's GET parameters.
        3. Assigns the retrieved Invoice to the Receipt object's `invoice` field.
        4. Saves the updated Receipt object to the database.
        5. Redirects the user to the 'invoice-list' URL.

        Args:
            form: The form instance that contains the submitted data for the Receipt.
        
        Returns:
            A HttpResponseRedirect to the 'invoice-list' URL upon successful form submission.

    get_context_data(**kwargs):
        Adds additional context data to the template context.

        1. Calls the superclass method to get the existing context.
        2. Retrieves the Invoice instance using the primary key provided in the request's GET parameters.
        3. Adds the retrieved Invoice to the context dictionary under the key 'invoice'.
        
        Args:
            **kwargs: Arbitrary keyword arguments.

        Returns:
            A dictionary representing the context to be used in the template."
StaffUpdateView,,"class StaffUpdateView(SuccessMessageMixin, UpdateView):
    model = Staff
    fields = '__all__'
    success_message = 'Record successfully updated.'

    def get_form(self):
        """"""add date picker in forms""""""
        form = super(StaffUpdateView, self).get_form()
        form.fields['date_of_birth'].widget = widgets.DateInput(attrs={
            'type': 'date'})
        form.fields['date_of_admission'].widget = widgets.DateInput(attrs={
            'type': 'date'})
        form.fields['address'].widget = widgets.Textarea(attrs={'rows': 1})
        form.fields['others'].widget = widgets.Textarea(attrs={'rows': 1})
        return form
",../../Django-School-Management-System/apps/staffs/views.py,views,views,class,,,646,"Fetches and modifies the form used for updating a staff member's record.

This method overrides the default `get_form` method to customize the widgets for certain fields in the form.
It performs the following steps:

1. Calls the parent class's `get_form` method to generate the initial form.
2. Modifies the 'date_of_birth' field to use a DateInput widget with the 'type' attribute set to 'date',
   which allows for a date picker interface.
3. Modifies the 'date_of_admission' field in a similar manner to 'date_of_birth' for consistency.
4. Changes the 'address' field to use a Textarea widget with 'rows' set to 1, likely to limit its size.
5. Adjusts the 'others' field to also use a Textarea widget with 'rows' set to 1, for a similar reason as 'address'.
6. Returns the modified form ready for rendering in the template.

The purpose of this method is to enhance the user experience by providing appropriate widgets for date selection
and to customize the display of text areas for better fitting the UI design.

Affected variables:
- `form`: An instance of the form class for the `Staff` model that is being updated. It is fetched from the parent class
  and then modified by adding custom widgets to certain fields."
StaffCreateView,,"class StaffCreateView(SuccessMessageMixin, CreateView):
    model = Staff
    fields = '__all__'
    success_message = 'New staff successfully added'

    def get_form(self):
        """"""add date picker in forms""""""
        form = super(StaffCreateView, self).get_form()
        form.fields['date_of_birth'].widget = widgets.DateInput(attrs={
            'type': 'date'})
        form.fields['date_of_admission'].widget = widgets.DateInput(attrs={
            'type': 'date'})
        form.fields['address'].widget = widgets.Textarea(attrs={'rows': 1})
        form.fields['others'].widget = widgets.Textarea(attrs={'rows': 1})
        return form
",../../Django-School-Management-System/apps/staffs/views.py,views,views,class,,,646,"Generates a form instance for creating a Staff object.

This method overrides the default get_form method to customize the widgets used for certain fields in the form. This customization includes adding a date picker widget to the 'date_of_birth' and 'date_of_admission' fields, and modifying the textarea widget for the 'address' and 'others' fields to have a specific number of rows.

Steps:
1. Retrieve the default form instance from the superclass' get_form method.
2. Replace the widget for the 'date_of_birth' field with a DateInput widget that includes a 'type' attribute set to 'date', enabling a date picker in forms.
3. Replace the widget for the 'date_of_admission' field with a DateInput widget similar to the 'date_of_birth' field.
4. Change the widget for the 'address' field to a Textarea widget with the 'rows' attribute set to 1, making it a single-line textarea.
5. Change the widget for the 'others' field to a Textarea widget with the 'rows' attribute also set to 1.
6. Return the modified form instance, which will be used to render the form in the template.

The purpose of this method is to enhance the user experience by providing appropriate input fields for different types of data, such as dates and text areas.

Variables affected:
- 'form': This is the form instance that is being modified and eventually returned."
forms,,"from django import forms
from django.forms import modelformset_factory
from apps.corecode.models import AcademicSession, AcademicTerm, Subject
from .models import Result


class CreateResults(forms.Form):
    session = forms.ModelChoiceField(queryset=AcademicSession.objects.all())
    term = forms.ModelChoiceField(queryset=AcademicTerm.objects.all())
    subjects = forms.ModelMultipleChoiceField(queryset=Subject.objects.all(
        ), widget=forms.CheckboxSelectMultiple)


EditResults = modelformset_factory(Result, fields=('test_score',
    'exam_score'), extra=0, can_delete=True)
",../../Django-School-Management-System/apps/result/forms.py,forms,,module,0.0,,589,nan
manage,Django's command-line utility for administrative tasks.,"""""""Django's command-line utility for administrative tasks.""""""
import os
import sys


def main():
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'school_app.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            ""Couldn't import Django. Are you sure it's installed and available on your PYTHONPATH environment variable? Did you forget to activate a virtual environment?""
            ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
",../../Django-School-Management-System/manage.py,manage,,module,0.0,,582,nan
StudentCreateView,,"class StudentCreateView(LoginRequiredMixin, SuccessMessageMixin, CreateView):
    model = Student
    fields = '__all__'
    success_message = 'New student successfully added.'

    def get_form(self):
        """"""add date picker in forms""""""
        form = super(StudentCreateView, self).get_form()
        form.fields['date_of_birth'].widget = widgets.DateInput(attrs={
            'type': 'date'})
        form.fields['address'].widget = widgets.Textarea(attrs={'rows': 2})
        form.fields['others'].widget = widgets.Textarea(attrs={'rows': 2})
        return form
",../../Django-School-Management-System/apps/students/views.py,views,views,class,,,570,"Creates and returns a form instance for the student creation view.

This method overrides the default get_form method to customize the widgets
for certain form fields. Specifically, it does the following:

1. Calls the superclass's get_form method to create the default form instance.
2. Customizes the 'date_of_birth' field by changing its widget to a DateInput widget,
   which allows the user to pick a date from a calendar pop-up.
3. Sets the HTML input type attribute for the 'date_of_birth' field to 'date' to ensure
   a proper date-select interface is provided.
4. Customizes the 'address' field by changing its widget to a Textarea widget,
   and setting the rows attribute to 2 to define the size of the text area.
5. Customizes the 'others' field in the same manner as the 'address' field,
   using a Textarea widget with the rows attribute set to 2.

After customizing the widgets for these fields, the method returns the modified form
instance to be used in the student creation view. This customization enhances the
user experience by providing appropriate input interfaces for different types of
data (e.g., dates and multi-line text).

Note: This method affects the 'date_of_birth', 'address', and 'others' fields of the form."
signals,,"from django.db.models.signals import post_save
from django.dispatch import receiver
from .models import Invoice


@receiver(post_save, sender=Invoice)
def after_creating_invoice(sender, instance, created, **kwargs):
    if created:
        previous_inv = Invoice.objects.filter(student=instance.student
            ).exclude(id=instance.id).last()
        if previous_inv:
            previous_inv.status = 'closed'
            previous_inv.save()
            instance.balance_from_previous_term = previous_inv.balance()
            instance.save()
",../../Django-School-Management-System/apps/finance/signals.py,signals,,module,0.0,,549,nan
ClassDeleteView,,"class ClassDeleteView(LoginRequiredMixin, DeleteView):
    model = StudentClass
    success_url = reverse_lazy('classes')
    template_name = 'corecode/core_confirm_delete.html'
    success_message = (
        'The class {} has been deleted with all its attached content')

    def delete(self, request, *args, **kwargs):
        obj = self.get_object()
        print(obj.name)
        messages.success(self.request, self.success_message.format(obj.name))
        return super(ClassDeleteView, self).delete(request, *args, **kwargs)
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,533,"Handles the HTTP DELETE request for deleting an object of type StudentClass.

This function overrides the delete method from the DeleteView class to perform
additional actions before deleting a StudentClass object.

Steps:
1. Retrieves the StudentClass object that is to be deleted by calling `self.get_object()`.
2. Prints the name of the StudentClass object to the console, which is useful for logging purposes.
3. Adds a success message to the request using Django's messages framework. This message
   includes the name of the class that is being deleted and is configured to be displayed
   after the redirect following the successful deletion.
4. Calls the delete method of the superclass (DeleteView) passing the HTTP request and any
   additional arguments and keyword arguments. This call to the superclass method actually
   performs the deletion of the object from the database.
5. The success_url attribute is used by the superclass to redirect the user to the 'classes'
   URL pattern upon successful deletion.

Variables affected:
- `obj`: The StudentClass object that is being retrieved and to be deleted.
- `success_message`: A formatted string containing a message indicating the successful deletion.

Purpose:
The purpose of this function is to delete a specific StudentClass object from the database
and provide feedback to the user with a success message indicating the deletion."
edit_results,,"@login_required
def edit_results(request):
    if request.method == 'POST':
        form = EditResults(request.POST)
        if form.is_valid():
            form.save()
            messages.success(request, 'Results successfully updated')
            return redirect('edit-results')
    else:
        results = Result.objects.filter(session=request.current_session,
            term=request.current_term)
        form = EditResults(queryset=results)
    return render(request, 'result/edit_results.html', {'formset': form})
",../../Django-School-Management-System/apps/result/views.py,views,views,function,,,524,"Edits the results of a particular session and term for the logged-in user.

The function first checks if the request method is a POST. If it is, it means that the form has been submitted:
- It creates an instance of the EditResults form and populates it with the data from the request.
- If the form is valid (all necessary fields are correctly filled in), it saves the form data to the database.
- Then, it displays a success message to the user indicating that the results have been successfully updated.
- Finally, it redirects the user to the 'edit-results' page.

If the request method is not POST (meaning it's likely a GET request), the function performs the following actions:
- It retrieves the Result objects that match the current user's session and term from the database.
- It creates an instance of the EditResults form with the queryset of the retrieved results.

In both cases, after processing the form or retrieving the initial data, the function renders the 'result/edit_results.html' template. It passes a context containing the form or formset to be displayed on the page.

Variables used:
- request: The HttpRequest object containing metadata about the request.
- form: The instance of the EditResults form class, either empty or with submitted data.
- results: The QuerySet containing Result objects filtered by the current session and term.
- 'result/edit_results.html': The path to the HTML template used to render the edit results page.
- {'formset': form}: The context dictionary containing the formset to be passed to the template.

Requires the user to be logged in, as denoted by the @login_required decorator."
SubjectDeleteView,,"class SubjectDeleteView(LoginRequiredMixin, DeleteView):
    model = Subject
    success_url = reverse_lazy('subjects')
    template_name = 'corecode/core_confirm_delete.html'
    success_message = (
        'The subject {} has been deleted with all its attached content')

    def delete(self, request, *args, **kwargs):
        obj = self.get_object()
        messages.success(self.request, self.success_message.format(obj.name))
        return super(SubjectDeleteView, self).delete(request, *args, **kwargs)
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,511,"Deletes the instance of the model associated with the current view.

This custom delete method:
1. Retrieves the object that needs to be deleted using the `get_object` method.
2. Sends a success message to the user using Django's messaging framework. This message includes the name of the object that is being deleted, which is formatted into the `success_message` string.
3. Calls the superclass's delete method to actually perform the deletion of the object.

Attributes:
    model: The model that the view is associated with, which in this case is `Subject`.
    success_url: The URL to redirect to after the object is deleted successfully. This is lazily reversed from the named URL pattern 'subjects'.
    template_name: The path to the template that displays the confirmation page for the delete action.
    success_message: A template string for the success message to be formatted with the name of the deleted object.

Parameters:
    request: The HTTP request object.
    *args: Variable length argument list.
    **kwargs: Arbitrary keyword arguments.

Returns:
    A HTTP response object that represents the result of the call to the superclass's delete method."
urls,,"from django.urls import path
from .views import StaffCreateView, StaffDeleteView, StaffDetailView, StaffListView, StaffUpdateView
urlpatterns = [path('list/', StaffListView.as_view(), name='staff-list'),
    path('<int:pk>/', StaffDetailView.as_view(), name='staff-detail'), path
    ('create/', StaffCreateView.as_view(), name='staff-create'), path(
    '<int:pk>/update/', StaffUpdateView.as_view(), name='staff-update'),
    path('<int:pk>/delete/', StaffDeleteView.as_view(), name='staff-delete')]
",../../Django-School-Management-System/apps/staffs/urls.py,urls,,module,0.0,,502,nan
DownloadCSVViewdownloadcsv,,"class DownloadCSVViewdownloadcsv(LoginRequiredMixin, View):

    def get(self, request, *args, **kwargs):
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'
            ] = 'attachment; filename=""student_template.csv""'
        writer = csv.writer(response)
        writer.writerow(['registration_number', 'surname', 'firstname',
            'other_names', 'gender', 'parent_number', 'address',
            'current_class'])
        return response
",../../Django-School-Management-System/apps/students/views.py,views,views,class,,,493,"Handles HTTP GET requests and returns a CSV file response.

This function is designed to be called when an HTTP GET request is made to the
corresponding URL. It performs the following steps:

1. Creates a new HttpResponse object with the content type set to 'text/csv',
   which indicates that the response will be a CSV file.
2. Sets the 'Content-Disposition' header of the response to suggest a default
   filename of ""student_template.csv"" for the downloaded file. This filename is
   used by web browsers to save the CSV file on the client's machine.
3. Initializes a CSV writer object using the HttpResponse object as the file-like
   object to write to.
4. Writes a single row to the CSV file using the writer object. This row contains
   headers for the columns: 'registration_number', 'surname', 'firstname',
   'other_names', 'gender', 'parent_number', 'address', and 'current_class'.
5. Returns the HttpResponse object containing the CSV data, which will prompt the
   browser to download the file.

Variables affected:
- response: An HttpResponse object that will hold the CSV content and headers.
- writer: A CSV writer object that is used to write the header row to the CSV file.

Purpose:
The purpose of this function is to provide a downloadable CSV file template with
predefined headers that can be used for data entry or other purposes related to
student information. It ensures that the user downloading the file is logged in
due to the use of LoginRequiredMixin."
middleware,,"from .models import AcademicSession, AcademicTerm


class SiteWideConfigs:

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        current_session = AcademicSession.objects.get(current=True)
        current_term = AcademicTerm.objects.get(current=True)
        request.current_session = current_session
        request.current_term = current_term
        response = self.get_response(request)
        return response
",../../Django-School-Management-System/apps/corecode/middleware.py,middleware,,module,0.0,,483,nan
main,,"def main():
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'school_app.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            ""Couldn't import Django. Are you sure it's installed and available on your PYTHONPATH environment variable? Did you forget to activate a virtual environment?""
            ) from exc
    execute_from_command_line(sys.argv)
",../../Django-School-Management-System/manage.py,manage,manage,function,,,457,"This function serves as the entry point for a Django application's command line interface.

Steps and purposes of the function:

1. Set the default environment variable 'DJANGO_SETTINGS_MODULE' to 'school_app.settings'.
   This step configures Django to use the settings from the specified module when it runs.

2. Try to import 'execute_from_command_line' from 'django.core.management'.
   This is a utility function provided by Django to execute commands from the command line.

3. Handle the ImportError exception if Django is not installed or not found in the environment.
   In case Django cannot be imported, the function raises a new ImportError with an explanatory message,
   suggesting that Django might not be installed or the virtual environment may not be activated.

4. Execute the 'execute_from_command_line' function with 'sys.argv' as an argument.
   This step passes the command line arguments to Django's management command interface to perform
   tasks such as running the server, creating migrations, etc.

Variables affected by the function:

- 'os.environ': The environment variables dictionary where 'DJANGO_SETTINGS_MODULE' is set.

Note: This function assumes that the 'os' and 'sys' modules have been imported before its definition,
as it uses 'os.environ' and 'sys.argv' without importing them within the function."
forms,,"from django.forms import inlineformset_factory, modelformset_factory
from .models import Invoice, InvoiceItem, Receipt
InvoiceItemFormset = inlineformset_factory(Invoice, InvoiceItem, fields=[
    'description', 'amount'], extra=1, can_delete=True)
InvoiceReceiptFormSet = inlineformset_factory(Invoice, Receipt, fields=(
    'amount_paid', 'date_paid', 'comment'), extra=0, can_delete=True)
Invoices = modelformset_factory(Invoice, exclude=(), extra=4)
",../../Django-School-Management-System/apps/finance/forms.py,forms,,module,0.0,,454,nan
SessionCreateView,,"class SessionCreateView(LoginRequiredMixin, SuccessMessageMixin, CreateView):
    model = AcademicSession
    form_class = AcademicSessionForm
    template_name = 'corecode/mgt_form.html'
    success_url = reverse_lazy('sessions')
    success_message = 'New session successfully added'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['title'] = 'Add new session'
        return context
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,450,"Extends the get_context_data method to pass additional context to the template.

This method is an override of the get_context_data method from the CreateView class. 
It adds an additional context variable 'title' alongside the default context 
variables provided by the superclass method.

Steps:
1. The method calls the superclass's get_context_data method to get the default 
   context dictionary.
2. It adds a new key-value pair to the context dictionary:
   a. 'title': A string that represents the title for the web page, which in this 
      case is set to 'Add new session'.
3. The updated context dictionary, now containing the 'title' key, is returned.

Purpose:
The purpose of this method is to provide the template with a specific title that 
can be used when rendering the web page. This is particularly useful for displaying 
the correct title on the page where the user is adding a new academic session.

Variables affected:
- context: The dictionary that holds context variables for the template. This method
  adds the 'title' key with the value 'Add new session' to it."
CurrentSessionForm,,"class CurrentSessionForm(forms.Form):
    current_session = forms.ModelChoiceField(queryset=AcademicSession.
        objects.all(), help_text=
        'Click <a href=""/session/create/?next=current-session/"">here</a> to add new session'
        )
    current_term = forms.ModelChoiceField(queryset=AcademicTerm.objects.all
        (), help_text=
        'Click <a href=""/term/create/?next=current-session/"">here</a> to add new term'
        )
",../../Django-School-Management-System/apps/corecode/forms.py,forms,forms,class,,,442,"This class represents a Django form for choosing a current academic session and term.

Attributes:
    current_session (forms.ModelChoiceField): A form field that allows the user to select from a queryset of all AcademicSession objects. This field provides a help_text attribute that includes an HTML link for adding a new session.
    
    current_term (forms.ModelChoiceField): A form field that allows the user to select from a queryset of all AcademicTerm objects. This field also provides a help_text attribute with an HTML link for adding a new term.

The purpose of this form is to enable users to select an academic session and term from the available options in the database or to navigate to a page where they can add a new session or term if the desired option is not available.

The docstring describes the class attributes defining the form fields and their configurations, including the querysets used to populate the dropdown menus and the help text associated with each field providing additional user instructions."
after_creating_invoice,,"@receiver(post_save, sender=Invoice)
def after_creating_invoice(sender, instance, created, **kwargs):
    if created:
        previous_inv = Invoice.objects.filter(student=instance.student
            ).exclude(id=instance.id).last()
        if previous_inv:
            previous_inv.status = 'closed'
            previous_inv.save()
            instance.balance_from_previous_term = previous_inv.balance()
            instance.save()
",../../Django-School-Management-System/apps/finance/signals.py,signals,signals,function,,,435,"This function is a receiver for the post_save signal of an Invoice model, which means it is called after an Invoice instance is saved.
The purpose of this function is to handle the post-creation logic for new Invoice instances.

The steps taken in this function are as follows:
1. It checks if the Invoice instance has just been created using the 'created' parameter.
2. If the instance is newly created, it retrieves the most recent Invoice for the same student, excluding the current instance.
3. If a previous invoice exists, it sets the status of that invoice to 'closed' and saves the changes to the database.
4. It then updates the balance_from_previous_term field of the newly created invoice with the balance from the previous invoice.
5. Finally, it saves the current instance with the updated balance_from_previous_term.

Variables affected in this function:
- previous_inv: An instance of the Invoice model representing the most recent invoice for the same student prior to the current instance.
- instance: The current instance of the Invoice model that has just been saved.

:param sender: The model class of the saved instance.
:param instance: The actual instance of the Invoice that has been saved.
:param created: A boolean flag indicating whether the instance is newly created or not.
:param kwargs: Additional keyword arguments."
SiteWideConfigs,,"class SiteWideConfigs:

    def __init__(self, get_response):
        self.get_response = get_response

    def __call__(self, request):
        current_session = AcademicSession.objects.get(current=True)
        current_term = AcademicTerm.objects.get(current=True)
        request.current_session = current_session
        request.current_term = current_term
        response = self.get_response(request)
        return response
",../../Django-School-Management-System/apps/corecode/middleware.py,middleware,middleware,class,,,431,"The '__call__' method is a special method that allows the object to be called as a function.

In this case, it is designed to be used as a middleware component in a web framework. 
When the object is called with a 'request' object:

1. It retrieves the current academic session from the database by querying the AcademicSession model 
   for an entry where 'current' is True.
2. It retrieves the current academic term from the database by querying the AcademicTerm model 
   for an entry where 'current' is True.
3. It assigns the retrieved current academic session to the 'request' object as an attribute named 'current_session'.
4. It assigns the retrieved academic term to the 'request' object as an attribute named 'current_term'.
5. It invokes the 'get_response' callable (typically the next middleware or view function in the processing pipeline) 
   with the 'request' object, which now includes the additional attributes.
6. It receives the 'response' from the 'get_response' callable.
7. Finally, it returns the 'response' object to the next processing stage.

This middleware effectively enriches the 'request' object with the current academic session and term, which can then be used 
by subsequent processing stages such as views or other middlewares."
context_processors,,"from .models import AcademicSession, AcademicTerm, SiteConfig


def site_defaults(request):
    current_session = AcademicSession.objects.get(current=True)
    current_term = AcademicTerm.objects.get(current=True)
    vals = SiteConfig.objects.all()
    contexts = {'current_session': current_session.name, 'current_term':
        current_term.name}
    for val in vals:
        contexts[val.key] = val.value
    return contexts
",../../Django-School-Management-System/apps/corecode/context_processors.py,context_processors,,module,0.0,,429,nan
wsgi,"WSGI config for school_app project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/howto/deployment/wsgi/","""""""
WSGI config for school_app project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/howto/deployment/wsgi/
""""""
import os
from django.core.wsgi import get_wsgi_application
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'school_app.settings')
application = get_wsgi_application()
",../../Django-School-Management-System/school_app/wsgi.py,wsgi,,module,0.0,,393,nan
InvoiceDetailView,,"class InvoiceDetailView(LoginRequiredMixin, DetailView):
    model = Invoice
    fields = '__all__'

    def get_context_data(self, **kwargs):
        context = super(InvoiceDetailView, self).get_context_data(**kwargs)
        context['receipts'] = Receipt.objects.filter(invoice=self.object)
        context['items'] = InvoiceItem.objects.filter(invoice=self.object)
        return context
",../../Django-School-Management-System/apps/finance/views.py,views,views,class,,,391,"Generates the context data for the invoice detail view.

This function extends the base implementation of `get_context_data` to add
additional context for the template. It performs the following steps:

1. Calls the base implementation of `get_context_data` to get the default context data,
   which includes the Invoice instance (referred to as `self.object`).

2. Queries the Receipt model for all receipts associated with the current invoice instance.
   The resulting queryset of receipts is added to the context dictionary under the key 'receipts'.

3. Queries the InvoiceItem model for all items associated with the current invoice instance.
   The resulting queryset of invoice items is added to the context dictionary under the key 'items'.

Finally, the function returns the updated context dictionary, which now includes the default context
data as well as the additional 'receipts' and 'items' data, ready to be used in the template.

Parameters:
- **kwargs: Arbitrary keyword arguments that are passed to the base implementation and can be
            used to extend the context if necessary.

Returns:
- dict: The context dictionary containing the default context data, along with the 'receipts'
        and 'items' data specific to the current invoice instance."
asgi,"ASGI config for newapp project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/howto/deployment/asgi/","""""""
ASGI config for newapp project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/3.0/howto/deployment/asgi/
""""""
import os
from django.core.asgi import get_asgi_application
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'newapp.settings')
application = get_asgi_application()
",../../Django-School-Management-System/school_app/asgi.py,asgi,,module,0.0,,385,nan
site_defaults,,"def site_defaults(request):
    current_session = AcademicSession.objects.get(current=True)
    current_term = AcademicTerm.objects.get(current=True)
    vals = SiteConfig.objects.all()
    contexts = {'current_session': current_session.name, 'current_term':
        current_term.name}
    for val in vals:
        contexts[val.key] = val.value
    return contexts
",../../Django-School-Management-System/apps/corecode/context_processors.py,context_processors,context_processors,function,,,365,"This function constructs a context dictionary with the current academic session and term,
as well as additional configurations from the SiteConfig model.

The function performs the following steps:
1. Retrieves the current academic session by querying the AcademicSession model for the entry
   where the 'current' field is set to True.
2. Retrieves the current academic term by querying the AcademicTerm model for the entry
   where the 'current' field is set to True.
3. Fetches all entries from the SiteConfig model to include additional site configuration settings.
4. Initializes the context dictionary with keys 'current_session' and 'current_term', setting
   their values to the names of the retrieved current academic session and term, respectively.
5. Iterates over all SiteConfig objects and adds each configuration to the context dictionary,
   using the 'key' field as the dictionary key and the 'value' field as the dictionary value.

Variables affected in the function:
- current_session: An instance of AcademicSession representing the current academic session.
- current_term: An instance of AcademicTerm representing the current academic term.
- vals: A queryset of SiteConfig objects containing all entries of site configuration.
- contexts: A dictionary that is initialized with the current session and term, and then populated
  with key-value pairs from SiteConfig objects.

The function returns the 'contexts' dictionary, which includes the current academic session,
the current academic term, and additional configuration settings from the SiteConfig model.

:param request: The HTTP request object (unused in this function but typically required for context processors).
:return: A dictionary containing the current academic session and term, along with additional site configurations."
StudentDetailView,,"class StudentDetailView(LoginRequiredMixin, DetailView):
    model = Student
    template_name = 'students/student_detail.html'

    def get_context_data(self, **kwargs):
        context = super(StudentDetailView, self).get_context_data(**kwargs)
        context['payments'] = Invoice.objects.filter(student=self.object)
        return context
",../../Django-School-Management-System/apps/students/views.py,views,views,class,,,344,"Extend the context data provided to the template for the student detail view.

This function customizes the context dictionary with additional data before it is passed to the template for rendering. Specifically, it performs the following steps:

1. Calls the base implementation of `get_context_data` to get the default context data, which includes the student information.

2. Adds a new entry to the context dictionary under the key 'payments'. This entry contains a QuerySet of Invoice objects associated with the student that is currently being viewed (represented by `self.object`).

3. Returns the updated context dictionary with the additional 'payments' data, which can be used in the template to display the payment information related to the student.

The function affects the following variables:
- `context`: The dictionary that will be passed to the template. It is initially populated with default values by the base implementation and then updated with the 'payments' data.

The purpose of this function is to provide the necessary data for rendering the student detail page, including both the student's information and their associated payments."
Receipt,,"class Receipt(models.Model):
    invoice = models.ForeignKey(Invoice, on_delete=models.CASCADE)
    amount_paid = models.IntegerField()
    date_paid = models.DateField(default=timezone.now)
    comment = models.CharField(max_length=200, blank=True)

    def __str__(self):
        return f'Receipt on {self.date_paid}'
",../../Django-School-Management-System/apps/finance/models.py,models,models,class,,,320,"Represents the string representation of the Receipt object.

This function overrides the built-in __str__ method to provide a human-readable string that represents the Receipt object. It returns a formatted string that includes the date on which the payment was made.

Returns:
    str: A string indicating that this is a receipt along with the date the payment was made, formatted as 'Receipt on YYYY-MM-DD'."
SessionListView,,"class SessionListView(LoginRequiredMixin, SuccessMessageMixin, ListView):
    model = AcademicSession
    template_name = 'corecode/session_list.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['form'] = AcademicSessionForm()
        return context
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,318,"Extends the context data provided to the template for rendering.

This function overrides the `get_context_data` method from the `ListView` class to provide additional context for the template. It is called when the view is rendered and ensures that additional data is available in the template context.

Steps:
1. It first calls the `get_context_data` method of the parent class (`ListView`) to get the default context data for the template.
2. It then creates a new instance of the `AcademicSessionForm` and adds it to the context dictionary under the key 'form'.

Purpose:
The purpose of this function is to pass the `AcademicSessionForm` to the template, which can then be rendered and used for user input.

Variables affected:
- `context`: A dictionary that is passed to the template. It is being modified by adding a new key-value pair where the key is 'form' and the value is a new instance of `AcademicSessionForm`.

The modified context dictionary with the added form is then returned, making it available to the template specified by the `template_name` attribute."
ClassListView,,"class ClassListView(LoginRequiredMixin, SuccessMessageMixin, ListView):
    model = StudentClass
    template_name = 'corecode/class_list.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['form'] = StudentClassForm()
        return context
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,308,"Extends the `get_context_data` method of a ListView to add a 'form' context variable.

This method is invoked to populate the context dictionary with information for the template.
It adds a new form instance to the context that will be used to render a StudentClassForm on the template.

Steps:
1. It calls `super().get_context_data(**kwargs)` to get the existing context from the base class.
2. It initializes a new StudentClassForm and assigns it to the 'form' key in the context dictionary.
3. Returns the updated context dictionary which now includes the 'form' entry along with the defaults.

The purpose of this function is to ensure that the context passed to the template includes a fresh instance of StudentClassForm, 
which can be used in the template to render the form fields for creating or editing StudentClass objects.

Variables affected:
- `context`: The dictionary that is passed to the template. It is modified by adding a new key-value pair where the key is 'form' and the value is an instance of StudentClassForm."
TermListView,,"class TermListView(LoginRequiredMixin, SuccessMessageMixin, ListView):
    model = AcademicTerm
    template_name = 'corecode/term_list.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['form'] = AcademicTermForm()
        return context
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,306,"Extend the context dictionary to be used in the template rendering.

This function customizes the context data sent to the template by adding an instance
of the AcademicTermForm to the context dictionary. The context is extended before the 
template is rendered, thereby making the form available in the template context so
that it can be used to render a form for creating or editing academic terms.

The function performs the following steps:
1. Calls the parent class's `get_context_data` method to obtain the default context.
2. Adds the 'form' key to the context dictionary with an instance of AcademicTermForm.
3. Returns the updated context dictionary.

This function affects the 'context' variable, which is a dictionary representing the 
context passed to the template. Specifically, it modifies this dictionary by adding 
a new key-value pair where 'form' is the key, and the newly created AcademicTermForm 
instance is the value.

Returns:
    dict: The updated context dictionary with the AcademicTermForm instance."
CreateResults,,"class CreateResults(forms.Form):
    session = forms.ModelChoiceField(queryset=AcademicSession.objects.all())
    term = forms.ModelChoiceField(queryset=AcademicTerm.objects.all())
    subjects = forms.ModelMultipleChoiceField(queryset=Subject.objects.all(
        ), widget=forms.CheckboxSelectMultiple)
",../../Django-School-Management-System/apps/result/forms.py,forms,forms,class,,,305,"This class 'CreateResults' inherits from Django's 'forms.Form' and is used to create a form that will be presented to the user for selecting an academic session, term, and multiple subjects.

Attributes:
- session (forms.ModelChoiceField): A drop-down field that allows the user to choose from a list of AcademicSession objects. The queryset for this field is populated with all instances of AcademicSession.
- term (forms.ModelChoiceField): A drop-down field that allows the user to select from a list of AcademicTerm objects. The queryset for this field is populated with all instances of AcademicTerm.
- subjects (forms.ModelMultipleChoiceField): A multiple selection field that allows the user to select one or more Subject objects. It uses a CheckboxSelectMultiple widget for a more user-friendly selection interface. The queryset for this field is populated with all instances of Subject.

The purpose of this form is to facilitate the creation of academic results by allowing the selection of a specific session, term, and the subjects for which results are to be created. Once the form is submitted, the selected options can be used to filter and manage the results for the chosen academic parameters."
SubjectListView,,"class SubjectListView(LoginRequiredMixin, SuccessMessageMixin, ListView):
    model = Subject
    template_name = 'corecode/subject_list.html'

    def get_context_data(self, **kwargs):
        context = super().get_context_data(**kwargs)
        context['form'] = SubjectForm()
        return context
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,302,"Fetch the context data for displaying the list of subjects.

This function extends the base implementation of `get_context_data` from the `ListView` generic view to include additional context for the template.

Steps:
1. Retrieve the base context provided by the `ListView` implementation, which includes the list of subjects.
2. Add a new 'form' entry to the context dictionary with an instance of `SubjectForm`. This form can be used for subject creation within the template.

Purpose:
The function aims to provide the necessary context data required for rendering the `subject_list.html` template. This includes both the list of subjects retrieved from the base class and a blank form for creating new subjects.

Variables Affected:
- `context`: The dictionary that holds context data for the template. This function adds a 'form' key to this dictionary.

:return: A dictionary containing context data for the template."
urls,,"from django.urls import path
from .views import ResultListView, create_result, edit_results
urlpatterns = [path('create/', create_result, name='create-result'), path(
    'edit-results/', edit_results, name='edit-results'), path('view/all',
    ResultListView.as_view(), name='view-results')]
",../../Django-School-Management-System/apps/result/urls.py,urls,,module,0.0,,293,nan
after_saving_session,Change all academic sessions to false if this is true,"@receiver(post_save, sender=AcademicSession)
def after_saving_session(sender, created, instance, *args, **kwargs):
    """"""Change all academic sessions to false if this is true""""""
    if instance.current is True:
        AcademicSession.objects.exclude(pk=instance.id).update(current=False)
",../../Django-School-Management-System/apps/corecode/signals.py,signals,signals,function,,,290,"This function is a callback for the post_save signal of an AcademicSession model instance. When an AcademicSession instance is saved, this function is triggered and performs the following actions:

1. Checks if the 'current' attribute of the instance being saved is set to True.
2. If the 'current' attribute is True, it proceeds to set the 'current' attribute of all other AcademicSession instances in the database to False, excluding the instance that was just saved.

Parameters:
- sender: The model class that just had an instance saved.
- created: A boolean flag that indicates whether a new record was created.
- instance: The actual instance of AcademicSession that was just saved.
- args: Variable length argument list.
- kwargs: Arbitrary keyword arguments.

This function ensures that only one AcademicSession instance has its 'current' attribute set to True at any given time. Essentially, it enforces a rule that only the most recently saved session marked as 'current=True' remains current, while all others are set to not current."
StudentBulkUploadView,,"class StudentBulkUploadView(LoginRequiredMixin, SuccessMessageMixin, CreateView
    ):
    model = StudentBulkUpload
    template_name = 'students/students_upload.html'
    fields = ['csv_file']
    success_url = '/student/list'
    success_message = 'Successfully uploaded students'
",../../Django-School-Management-System/apps/students/views.py,views,views,class,,,284,"This class-based view handles the bulk upload of student information via a CSV file.

It inherits from LoginRequiredMixin, SuccessMessageMixin, and CreateView, ensuring
that the user must be logged in to access the view, a success message is provided upon
successful upload, and the view is used to create a new object respectively.

The view is associated with the StudentBulkUpload model, which likely represents
a record of a bulk upload operation.

Attributes:
    - model: Indicates the model that this view will create instances of, which is StudentBulkUpload.
    - template_name: The path to the HTML template used to render the bulk upload page.
    - fields: A list containing 'csv_file', specifying that the only field to be handled by this view
              is the CSV file containing student data.
    - success_url: The URL to redirect to after a successful upload, which is set to the student list page.
    - success_message: A message displayed to the user upon successful upload of the student data.

The view does not explicitly define methods but relies on the behavior inherited from CreateView and mixins
to handle file upload form rendering, submission, and processing of the CSV data.

Variables Affected:
- None are directly affected within this class definition as it primarily sets up configurations, but
  the 'csv_file' field is expected to be processed by the underlying CreateView methods to create
  instances of StudentBulkUpload model.

Purpose:
The purpose of this view is to provide a user interface for uploading a CSV file containing student
information and to create records of these bulk upload operations in the database. It simplifies the process
of adding multiple students to the system by automating the ingestion of data from a standardized file format."
after_saving_term,Change all academic terms to false if this is true.,"@receiver(post_save, sender=AcademicTerm)
def after_saving_term(sender, created, instance, *args, **kwargs):
    """"""Change all academic terms to false if this is true.""""""
    if instance.current is True:
        AcademicTerm.objects.exclude(pk=instance.id).update(current=False)
",../../Django-School-Management-System/apps/corecode/signals.py,signals,signals,function,,,279,"After saving an AcademicTerm instance, this function ensures that only one AcademicTerm
is marked as the current term.

If the newly saved or updated AcademicTerm instance (`instance`) has its `current` field set to `True`,
the function updates all other AcademicTerm instances in the database (excluding the one just saved or updated)
by setting their `current` fields to `False`. This guarantees that there is only one active AcademicTerm
marked as current at any given time.

Variables:
- sender: The model class that sent the signal. In this case, it is AcademicTerm.
- created: A boolean flag indicating whether a new AcademicTerm instance was created or not.
- instance: The actual AcademicTerm instance that was saved or updated.
- args: Additional positional arguments (not used in this function).
- kwargs: Additional keyword arguments (not used in this function).

The function does not return any value and affects the `current` field of AcademicTerm instances in the database."
ClassCreateView,,"class ClassCreateView(LoginRequiredMixin, SuccessMessageMixin, CreateView):
    model = StudentClass
    form_class = StudentClassForm
    template_name = 'corecode/mgt_form.html'
    success_url = reverse_lazy('classes')
    success_message = 'New class successfully added'
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,275,"This docstring describes the ClassCreateView class, which inherits from LoginRequiredMixin, 
SuccessMessageMixin, and CreateView, and is used to create a new instance of StudentClass.

The following steps are taken within the class:

1. The `model` attribute is set to StudentClass, which specifies that this view will be used 
   to create objects of the StudentClass model.

2. The `form_class` attribute is set to StudentClassForm, which defines the form that will be 
   used to create a new StudentClass instance.

3. The `template_name` attribute is set to 'corecode/mgt_form.html', which determines the HTML 
   template that will be used to display the form for creating a new StudentClass.

4. The `success_url` attribute is set using reverse_lazy to generate a URL to redirect to after 
   a successful creation of a StudentClass instance. The URL corresponds to the 'classes' view.

5. The `success_message` attribute is set to 'New class successfully added', which is a message 
   that will be displayed to the user upon the successful creation of a StudentClass.

This class is a Django view that requires a user to be logged in (LoginRequiredMixin) to access 
the form for creating a new class. Upon successful submission of the form, a success message 
(SuccessMessageMixin) is displayed to the user, and the user is redirected to the 'classes' view."
TermCreateView,,"class TermCreateView(LoginRequiredMixin, SuccessMessageMixin, CreateView):
    model = AcademicTerm
    form_class = AcademicTermForm
    template_name = 'corecode/mgt_form.html'
    success_url = reverse_lazy('terms')
    success_message = 'New term successfully added'
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,271,"A view for creating a new academic term within a web application.

The `TermCreateView` extends the `LoginRequiredMixin`, `SuccessMessageMixin`, and `CreateView`
classes, indicating that it is a view for handling the creation of new objects, requiring the user to be logged in, and providing a success message upon successful creation.

Attributes:
    model (Model): The Django model that represents an academic term, which is `AcademicTerm`.
    form_class (ModelForm): The Django form class used for creating an `AcademicTerm` object, which is `AcademicTermForm`.
    template_name (str): The path to the HTML template used to render the term creation form, which is 'corecode/mgt_form.html'.
    success_url (str): The URL to redirect to upon successful creation of a term, which is resolved lazily to the 'terms' URL pattern.
    success_message (str): A message that is displayed to the user upon the successful creation of a term, which is 'New term successfully added'.

This class does not define any methods but leverages the functionality provided by its parent classes to:
- Require user authentication for accessing the term creation form.
- Provide and process a form for creating `AcademicTerm` objects.
- Render the template specified by `template_name` with the form.
- Redirect to `success_url` upon successful form submission and term creation.
- Display `success_message` to the user upon successful term creation."
SubjectCreateView,,"class SubjectCreateView(LoginRequiredMixin, SuccessMessageMixin, CreateView):
    model = Subject
    form_class = SubjectForm
    template_name = 'corecode/mgt_form.html'
    success_url = reverse_lazy('subjects')
    success_message = 'New subject successfully added'
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,270,"A class-based view that handles the creation of a new Subject instance.

This view extends the LoginRequiredMixin, SuccessMessageMixin, and CreateView classes 
from Django, ensuring that the user must be authenticated to access the view, a success 
message is displayed upon successfully creating an object, and the view is tailored to 
create an object linked to a database model.

Attributes:
    model: The database model that the view is associated with, which is 'Subject' in this case.
    form_class: The form used to create a new Subject instance, specified by 'SubjectForm'.
    template_name: The path to the HTML template used to render the form, set to 'corecode/mgt_form.html'.
    success_url: The URL to redirect to after a successful creation, which is the URL with the name 'subjects'.
    success_message: The message displayed to the user upon successful creation of a new subject, stating
                     'New subject successfully added'.

Steps:
1. The view inherits behavior from LoginRequiredMixin to ensure that only authenticated users can access it.
2. It uses SuccessMessageMixin to set up a message that will be displayed when a new Subject is successfully created.
3. CreateView is extended to provide the functionality to create a new Subject instance using the specified form_class.
4. Upon successful creation of the Subject, the user is redirected to the URL defined in success_url.
5. The success_message attribute defines the message that will be displayed to the user upon successful creation.
"""""" "
AcademicSession,Academic Session,"class AcademicSession(models.Model):
    """"""Academic Session""""""
    name = models.CharField(max_length=200, unique=True)
    current = models.BooleanField(default=True)


    class Meta:
        ordering = ['-name']

    def __str__(self):
        return self.name
",../../Django-School-Management-System/apps/corecode/models.py,models,models,class,,,265,"Converts the object to its string representation.

This function is a special method that is automatically called when an object of the AcademicSession class is converted to a string (e.g., when using the print() function or when using str()). It returns the 'name' attribute of the AcademicSession instance, which is a string containing the name of the academic session.

:return: A string representation of the AcademicSession object, specifically the name of the academic session."
ClassUpdateView,,"class ClassUpdateView(LoginRequiredMixin, SuccessMessageMixin, UpdateView):
    model = StudentClass
    fields = ['name']
    success_url = reverse_lazy('classes')
    success_message = 'class successfully updated.'
    template_name = 'corecode/mgt_form.html'
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,262,"A view for updating an instance of StudentClass.

This class-based view is used in the context of a web application where a user, who must be logged in, can update the details of an existing class (StudentClass model). The view inherits from Django's built-in mixins and views to enforce user authentication and to provide feedback after a successful operation.

Attributes:
    model: The model that this view will be updating. In this case, it is set to 'StudentClass', which represents the class to be updated.
    fields: A list of model fields that are allowed to be edited. Here, only the 'name' field of the StudentClass model can be updated through this view.
    success_url: A URL to redirect the user to after a successful update. Here, it is set to reverse_lazy('classes'), which means it will lazily resolve the URL named 'classes'.
    success_message: A message to display to the user upon successful update of the class. It is set to 'class successfully updated.'.
    template_name: The path to the HTML template used to render the update form. It is set to 'corecode/mgt_form.html'.

Functions within ClassUpdateView:

    get_form(self, form_class=None):
        - Retrieves and returns the form instance that should be used for getting and validating the form data.
        - The 'form_class' argument allows for customization of the form class to be used.
        - By default, it uses the form class defined by the 'fields' attribute or the default modelform_factory for the 'model' attribute.

    form_valid(self, form):
        - Defines what to do when valid form data is posted.
        - It saves the updated instance of StudentClass and sets the success message.
        - Redirects the user to the 'success_url'.

    form_invalid(self, form):
        - Defines the behavior when form validation fails.
        - By default, it re-renders the form with validation errors.

Usage:
    This view is intended to be mapped to a URL pattern. When a request is made to that URL, the view handles fetching the specific StudentClass instance, rendering the form with existing data, validating the user input, and saving changes to the instance.

Note:
    - The LoginRequiredMixin ensures that only authenticated users can access this view.
    - The SuccessMessageMixin allows for easy display of the 'success_message' when the class is updated successfully."
SubjectUpdateView,,"class SubjectUpdateView(LoginRequiredMixin, SuccessMessageMixin, UpdateView):
    model = Subject
    fields = ['name']
    success_url = reverse_lazy('subjects')
    success_message = 'Subject successfully updated.'
    template_name = 'corecode/mgt_form.html'
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,262,"This class-based view, SubjectUpdateView, inherits from LoginRequiredMixin, 
SuccessMessageMixin, and UpdateView, which are provided by Django for handling 
the update functionality in a web application with authentication and success messages.

In its implementation:

- The `model` attribute specifies the Django model that is being updated, 
  which in this case is the `Subject` model.

- The `fields` attribute lists the fields that are allowed to be updated through 
  this view. Here, only the 'name' field of the Subject model can be updated.

- The `success_url` attribute defines the URL to redirect to after a successful update. 
  The `reverse_lazy` function is used to lazily reverse the 'subjects' URL pattern, 
  ensuring that it will not be evaluated until it is needed.

- The `success_message` attribute provides a message that will be displayed to the user 
  once the subject has been successfully updated, which in this case is 'Subject successfully updated.'

- The `template_name` attribute indicates the path to the template file that is used to render 
  the update form. In this instance, the template is located at 'corecode/mgt_form.html'.

The view handles the update operation by displaying a form populated with the existing subject's data, 
allowing the user to edit the 'name' field and then saving the changes to the database upon form submission. 
It also ensures that only authenticated users can access this functionality and provides a user-friendly 
message upon successful completion of the update process."
AcademicTerm,Academic Term,"class AcademicTerm(models.Model):
    """"""Academic Term""""""
    name = models.CharField(max_length=20, unique=True)
    current = models.BooleanField(default=True)


    class Meta:
        ordering = ['name']

    def __str__(self):
        return self.name
",../../Django-School-Management-System/apps/corecode/models.py,models,models,class,,,257,"A string representation of the AcademicTerm instance.

This function overrides the default __str__ method to return the 'name'
of the AcademicTerm instance, which is a field representing the term name.

The purpose of this method is to provide a human-readable representation of the
AcademicTerm object, which can be used for display purposes in admin interfaces
or in debugging output. When an instance of AcademicTerm is converted to a string,
the term name will be outputted, thanks to this method.

Variables affected:
- 'name': The 'name' field of the AcademicTerm model, which holds the
          name of the academic term and is returned as the string representation."
StudentClass,,"class StudentClass(models.Model):
    name = models.CharField(max_length=200, unique=True)


    class Meta:
        verbose_name = 'Class'
        verbose_name_plural = 'Classes'
        ordering = ['name']

    def __str__(self):
        return self.name
",../../Django-School-Management-System/apps/corecode/models.py,models,models,class,,,257,"Represents a class model for a student, containing the class name as its primary attribute.

Attributes:
    name (models.CharField): The name of the class, which must be unique and has a maximum length of 200 characters.

Class Meta:
    verbose_name (str): A human-readable single-object name for the class model.
    verbose_name_plural (str): A human-readable plural name for the class model.
    ordering (list): A list that specifies the default ordering for the class model; it orders by 'name' in ascending order.

Methods:
    __str__(self):
        This magic method is used to return a human-readable string representation of the StudentClass object.
        When an instance of StudentClass is printed or converted to string, the class's 'name' attribute will be returned.

        Returns:
            str: The name of the class as a string."
Subject,Subject,"class Subject(models.Model):
    """"""Subject""""""
    name = models.CharField(max_length=200, unique=True)


    class Meta:
        ordering = ['name']

    def __str__(self):
        return self.name
",../../Django-School-Management-System/apps/corecode/models.py,models,models,class,,,199,"Return the string representation of the Subject instance.

This method overrides the default `__str__` method to provide a human-readable string representation of the Subject object.
When the Subject instance is printed or converted to a string, this method will be called.

Returns:
    str: The name of the Subject instance, which is the content of the 'name' field of the Subject model."
InvoiceItem,,"class InvoiceItem(models.Model):
    invoice = models.ForeignKey(Invoice, on_delete=models.CASCADE)
    description = models.CharField(max_length=200)
    amount = models.IntegerField()
",../../Django-School-Management-System/apps/finance/models.py,models,models,class,,,186,"A Django model representing an item on an invoice.

Attributes:
    invoice (models.ForeignKey): A reference to the associated Invoice object, with a CASCADE on-delete behavior,
        meaning that when the referenced Invoice is deleted, this InvoiceItem will also be deleted.
    description (models.CharField): A description of the invoice item, represented as a CharField with a maximum length of 200 characters.
    amount (models.IntegerField): The amount of the invoice item, represented as an IntegerField.
    
This model is typically used to store individual items that make up an invoice, where each item has a description and an associated amount. 
It is linked to an Invoice model instance, allowing for the representation of a one-to-many relationship between an Invoice and its items."
SiteConfig,Site Configurations,"class SiteConfig(models.Model):
    """"""Site Configurations""""""
    key = models.SlugField()
    value = models.CharField(max_length=200)

    def __str__(self):
        return self.key
",../../Django-School-Management-System/apps/corecode/models.py,models,models,class,,,184,"Convert the SiteConfig instance to its string representation.

This function overrides the default string representation for instances of the SiteConfig class. When a SiteConfig object is converted to a string, this method is called to determine the format of that string. 

The function uses the `key` attribute of the SiteConfig instance, which is expected to be a SlugField, and returns it. This means that whenever a SiteConfig object is printed or formatted as a string, only its `key` attribute will be represented as a string, not the `value` attribute or any other information about the object.

The purpose of this function is to provide a human-readable identifier for each SiteConfig instance, which can be useful for debugging or in the Django admin interface, where objects are often identified by their string representation.

Variables affected:
- `self.key`: The 'key' attribute of the SiteConfig instance is used to create the string representation.

There are no other side effects or changes to object state within the function."
total_amount_paid,,"def total_amount_paid(self):
    receipts = Receipt.objects.filter(invoice=self)
    amount = 0
    for receipt in receipts:
        amount += receipt.amount_paid
    return amount
",../../Django-School-Management-System/apps/finance/models.py,models,models,function,,,181,"Calculates the total amount paid for a particular invoice.

This function aggregates the total amount of money paid across all receipts associated with the invoice instance it is called on.

Steps:
1. It queries the database for all receipts linked to the specific invoice instance (self).
2. It initializes a variable 'amount' to zero, which will hold the cumulative amount paid.
3. It iterates through each receipt in the query result:
    a. For each receipt, it accesses the 'amount_paid' attribute.
    b. It then adds this amount to the 'amount' variable.
4. After summing up all the amounts from the receipts, it returns the total 'amount'.

Variables:
- receipts: A QuerySet containing all Receipt objects related to the invoice instance.
- amount: An integer or decimal (depending on the field type of 'amount_paid') that holds the running total of all payments made.

Returns:
- The total amount paid as an integer or decimal, representing the sum of the 'amount_paid' fields of all the receipts associated with the invoice."
ReceiptUpdateView,,"class ReceiptUpdateView(LoginRequiredMixin, UpdateView):
    model = Receipt
    fields = ['amount_paid', 'date_paid', 'comment']
    success_url = reverse_lazy('invoice-list')
",../../Django-School-Management-System/apps/finance/views.py,views,views,class,,,177,"A view for updating a Receipt instance.

This view inherits from Django's `LoginRequiredMixin`, ensuring that a user must be logged in to access this view, and `UpdateView`, which provides a generic way to update an instance of a model.

Attributes:
    model: The Django model class that this view will update instances of. In this case, the `Receipt` model.
    fields: A list of model field names that will be included in the form presented to the user. The fields are 'amount_paid', 'date_paid', and 'comment'.
    success_url: A lazy reverse URL to which the user will be redirected upon successful submission of the form. It is set to the named URL 'invoice-list'.

The view handles GET and POST requests. For GET requests, it presents a form populated with an existing Receipt instance's data. For POST requests, it attempts to update the Receipt instance with the data submitted in the form.

On successful form submission and receipt update, the user is redirected to the URL defined in `success_url`. If the form is not valid, the form is re-presented with validation errors.

This view requires the user to be authenticated, as enforced by `LoginRequiredMixin`."
delete_csv_file,,"@receiver(post_delete, sender=StudentBulkUpload)
def delete_csv_file(sender, instance, *args, **kwargs):
    if instance.csv_file:
        _delete_file(instance.csv_file.path)
",../../Django-School-Management-System/apps/students/signals.py,signals,signals,function,,,176,"This function is a signal receiver that is triggered after a `StudentBulkUpload` instance is deleted.
It is connected to the `post_delete` signal, which is sent by Django's ORM when an object is deleted.

The function performs the following steps:
1. It checks if the `csv_file` attribute of the `StudentBulkUpload` instance exists.
2. If the `csv_file` exists, it calls the `_delete_file` helper function, passing the file path of the `csv_file`.

The purpose of the function is to ensure that the CSV file associated with a `StudentBulkUpload` instance is also
deleted from the filesystem when the instance itself is deleted from the database.

Parameters:
- sender: The model class of the deleted instance.
- instance: The actual instance of `StudentBulkUpload` that was deleted.
- *args: Additional positional arguments (not used in this function).
- **kwargs: Additional keyword arguments (not used in this function).

Variables affected:
- instance.csv_file: The `FileField` attribute of the `StudentBulkUpload` instance that may hold the CSV file to be deleted."
delete_passport_on_delete,,"@receiver(post_delete, sender=Student)
def delete_passport_on_delete(sender, instance, *args, **kwargs):
    if instance.passport:
        _delete_file(instance.passport.path)
",../../Django-School-Management-System/apps/students/signals.py,signals,signals,function,,,176,"This function acts as a signal receiver, which is triggered after a `Student` record is deleted from the database (post_delete). 

Its purpose is to delete the associated passport file from the filesystem when a `Student` instance is removed. 

Parameters:
- sender: The model class that sent the signal. In this case, it should be the `Student` model.
- instance: The instance of the model that's being deleted.
- *args: Variable length argument list.
- **kwargs: Arbitrary keyword arguments.

Steps:
1. The function checks if the `passport` attribute of the `Student` instance exists.
2. If the `passport` attribute exists, the function proceeds to call the helper function `_delete_file`.
3. The `_delete_file` function is then given the path of the passport file to delete it from the filesystem.

Variables:
- instance.passport: A model field of the `Student` instance, expected to be a file field that holds the passport information.
- instance.passport.path: The filesystem path to the passport file associated with the `Student` instance.

Note: The helper function `_delete_file` is not defined within this code snippet, so it is assumed to be a function that takes a file path as input and handles the deletion process."
amount_payable,,"def amount_payable(self):
    items = InvoiceItem.objects.filter(invoice=self)
    total = 0
    for item in items:
        total += item.amount
    return total
",../../Django-School-Management-System/apps/finance/models.py,models,models,function,,,162,"Calculates the total amount payable for an invoice.

This function iterates over all items associated with a specific invoice and sums up the individual amounts to calculate the total amount payable. It performs the following steps:

1. Retrieves all invoice items related to the current invoice instance using a filter query on the InvoiceItem model, where the invoice is set to self (the current invoice instance).
2. Initializes a total variable to 0, which will accumulate the sum of amounts of all invoice items.
3. Iterates over each invoice item in the retrieved list of items.
4. Adds the amount of each item to the total sum.
5. After summing up all amounts, the function returns the total as the amount payable for the invoice.

Variables affected:
- items: A QuerySet containing all invoice items related to the current invoice.
- total: An integer or decimal (depending on the amount field in InvoiceItem), representing the total amount payable.

Returns:
- The function returns the total amount payable as a numeric value (integer or decimal)."
StudentBulkUpload,,"class StudentBulkUpload(models.Model):
    date_uploaded = models.DateTimeField(auto_now=True)
    csv_file = models.FileField(upload_to='students/bulkupload/')
",../../Django-School-Management-System/apps/students/models.py,models,models,class,,,161,"Represents a database model for handling bulk uploads of student data via CSV files.

Attributes:
    date_uploaded (models.DateTimeField): Records the datetime when the file was uploaded.
        This field is automatically updated to the current datetime every time the object is saved.
    csv_file (models.FileField): Represents the uploaded CSV file containing student data.
        The file is stored in the 'students/bulkupload/' directory. The upload_to parameter specifies
        this path where the file will be stored in the server.

The model does not contain any methods, but it is structured to work with Django's ORM system.
Instances of this model can be created to store information about each bulk upload operation,
including the timestamp of the upload and a reference to the CSV file itself."
AcademicSessionForm,,"class AcademicSessionForm(ModelForm):
    prefix = 'Academic Session'


    class Meta:
        model = AcademicSession
        fields = ['name', 'current']
",../../Django-School-Management-System/apps/corecode/forms.py,forms,forms,class,,,157,"A `ModelForm` subclass called `AcademicSessionForm` for creating and updating instances of the `AcademicSession` model.

Attributes:
    prefix (str): A string that will be prefixed to the form's field names.

The `Meta` inner class:
    - Specifies the `AcademicSession` model that the form is linked to.
    - Defines a list of fields (`name`, `current`) that will be included in the form. 

The form will facilitate the creation and modification of `AcademicSession` instances, specifically its 'name' and 
'current' attributes, through user input in a web interface or other form-handling views. The `prefix` attribute is used 
to differentiate form field names when multiple forms are used on the same HTML page, avoiding name collisions.

Example:
    When rendering the form in a template, the 'name' field would be represented as 'Academic Session-name' and the 
    'current' field as 'Academic Session-current' due to the specified prefix.

This class does not define any additional methods beyond those provided by `ModelForm`, but it customizes the form's 
behavior through the `Meta` class configuration."
apps,,"from django.apps import AppConfig


class StudentsConfig(AppConfig):
    name = 'apps.students'

    def ready(self):
        import apps.students.signals
",../../Django-School-Management-System/apps/students/apps.py,apps,,module,0.0,,155,nan
apps,,"from django.apps import AppConfig


class CorecodeConfig(AppConfig):
    name = 'apps.corecode'

    def ready(self):
        import apps.corecode.signals
",../../Django-School-Management-System/apps/corecode/apps.py,apps,,module,0.0,,155,nan
apps,,"from django.apps import AppConfig


class FinanceConfig(AppConfig):
    name = 'apps.finance'

    def ready(self):
        import apps.finance.signals
",../../Django-School-Management-System/apps/finance/apps.py,apps,,module,0.0,,152,nan
AcademicTermForm,,"class AcademicTermForm(ModelForm):
    prefix = 'Academic Term'


    class Meta:
        model = AcademicTerm
        fields = ['name', 'current']
",../../Django-School-Management-System/apps/corecode/forms.py,forms,forms,class,,,148,"A Django ModelForm for the AcademicTerm model.

Attributes:
    prefix (str): A prefix used to distinguish form fields in the HTML.

Meta:
    model: The Django model associated with this form, which is AcademicTerm.
    fields (list): A list of the model fields that this form will include. In this case, it includes 'name' and 'current'.

The form created by this class can be used to create or update AcademicTerm instances. It will present input fields for the 'name' of the academic term, which is a descriptive name for the term, and a boolean 'current' field to indicate whether this term is the current active term or not.

The 'prefix' attribute is particularly useful when multiple forms are used on the same HTML page, to avoid name clashes between form fields. By setting 'prefix' to 'Academic Term', all fields of this form will be prefixed with 'Academic Term-', ensuring their uniqueness.

Example:
    Form usage in a Django view could look like this:

    form = AcademicTermForm(request.POST or None)
    if form.is_valid():
        term = form.save()"
__str__,,"def __str__(self):
    return (
        f'{self.surname} {self.firstname} {self.other_name} ({self.registration_number})'
        )
",../../Django-School-Management-System/apps/students/models.py,models,models,function,,,132,"This method overrides the built-in __str__ method to provide a string representation of the object. 

The method concatenates four attributes of the object: surname, firstname, other_name, and registration_number, separated by spaces. The registration_number is enclosed within parentheses. This string reflects a human-readable format that is typically used to display the full name and identification of an individual.

The method returns a formatted string which includes:
- The surname of the individual.
- The firstname of the individual.
- The other_name of the individual, which might be a middle name or additional names.
- The registration_number of the individual, enclosed in parentheses to denote its significance as an identifier.

The purpose of this method is to provide a consistent and formatted string representation of the object's key information, primarily for display or logging purposes.

The variables affected by this function are:
- self.surname: A string representing the last name of the individual.
- self.firstname: A string representing the first name of the individual.
- self.other_name: A string representing the middle or additional names of the individual.
- self.registration_number: A string or numeric value representing the individual's unique registration number.

The function does not modify any of these variables but simply reads their values to construct the return string."
StudentClassForm,,"class StudentClassForm(ModelForm):
    prefix = 'Class'


    class Meta:
        model = StudentClass
        fields = ['name']
",../../Django-School-Management-System/apps/corecode/forms.py,forms,forms,class,,,129,"A Django ModelForm for representing a form associated with the StudentClass model.

This class is a subclass of Django's ModelForm and is used to generate and process forms for creating or updating 
StudentClass instances. It includes a single Meta class that provides Django with the necessary information to build 
the form.

Attributes:
    prefix (str): A string used to prefix the form fields' HTML name attributes. This can be useful to distinguish 
                  form fields when multiple forms are used on the same page.

Meta:
    model: A reference to the StudentClass model that this form represents. The form will include fields that correspond 
           to the attributes of this model.

    fields (list): A list of strings that specify which fields of the model should be included in the form. In this case, 
                   the form will only include the 'name' field of the StudentClass model.

The StudentClassForm does not define any additional methods or attributes. It relies on the functionality provided by 
Django's ModelForm to handle the creation and processing of forms based on the provided Meta class configuration."
ReceiptDeleteView,,"class ReceiptDeleteView(LoginRequiredMixin, DeleteView):
    model = Receipt
    success_url = reverse_lazy('invoice-list')
",../../Django-School-Management-System/apps/finance/views.py,views,views,class,,,124,"A view that handles the deletion of a Receipt object.

This class is a Django view that extends the functionality of the LoginRequiredMixin,
which ensures that only authenticated users can access this view, and the DeleteView,
which provides a generic way to delete a particular object.

Attributes:
    model: The model that this view will act upon. In this case, it's the Receipt model,
           which represents the database table where receipt records are stored.
    success_url: A lazy reverse lookup for the URL to which the user will be redirected
                 after successfully deleting a Receipt object. The 'invoice-list' URL name
                 is used to find the corresponding URL pattern.

The view automatically handles the following steps:
1. It checks if the user is authenticated using the LoginRequiredMixin. If the user is not
   authenticated, it redirects to the login page.
2. It retrieves the Receipt object to be deleted based on the object's ID passed in the URL.
3. It deletes the Receipt object from the database upon a valid HTTP POST request.
4. After successful deletion, it redirects the user to the URL defined in 'success_url',
   which should correspond to the list view of invoices (or similar).

Note:
The actual deletion and redirection logic is handled by Django's DeleteView and is not explicitly
defined in this class. The 'model' and 'success_url' attributes are configurations that guide
the DeleteView on what to delete and where to redirect after deletion."
StudentDeleteView,,"class StudentDeleteView(LoginRequiredMixin, DeleteView):
    model = Student
    success_url = reverse_lazy('student-list')
",../../Django-School-Management-System/apps/students/views.py,views,views,class,,,124,"A view that handles the deletion of a Student object.

This class inheres from LoginRequiredMixin and DeleteView which means that it requires the user to be logged in to access this view and provides a generic view for deleting objects.

Attributes:
- model (Model): The Django model which in this case is the Student model. This tells the DeleteView which type of object will be deleted.
- success_url (str): A lazy reverse URL to redirect to upon successful deletion of the object. It points to the 'student-list' URL, which is presumably the view that lists all Student objects.

The StudentDeleteView automatically handles the process of deleting a Student object from the database when it's invoked. The success_url ensures that the user is redirected to the list of remaining Student objects after a successful deletion."
InvoiceDeleteView,,"class InvoiceDeleteView(LoginRequiredMixin, DeleteView):
    model = Invoice
    success_url = reverse_lazy('invoice-list')
",../../Django-School-Management-System/apps/finance/views.py,views,views,class,,,124,"This class-based view, `InvoiceDeleteView`, extends Django's built-in `DeleteView` and 
requires a user to be logged in (as it also inherits from `LoginRequiredMixin`). 

The class is designed to handle the deletion of `Invoice` objects.

Attributes:
    model: A Django model class, `Invoice`, which represents the database model that 
           this view will interact with. This is the model that instances will be 
           deleted from.
    success_url: A lazy URL reversal for the named URL pattern 'invoice-list'. This 
                 defines the redirect URL to which the user will be sent after a 
                 successful deletion.

The view's main purpose is to delete an instance of the `Invoice` model and then redirect 
the user to the 'invoice-list' URL. The deletion process and the redirection are handled 
by Django's built-in mechanisms, which the `DeleteView` provides. The `LoginRequiredMixin` 
ensures that only authenticated users can access this functionality.

The view does not define any methods, as the necessary logic is inherited from the 
parent classes (`LoginRequiredMixin` and `DeleteView`). The `model` attribute tells 
the `DeleteView` which model instances to delete, and `success_url` specifies where 
to redirect the user upon successful deletion."
balance,,"def balance(self):
    payable = self.total_amount_payable()
    paid = self.total_amount_paid()
    return payable - paid
",../../Django-School-Management-System/apps/finance/models.py,models,models,function,,,123,"Calculates and returns the current balance of an account by determining the amount payable and the amount already paid.

This function performs the following steps:
1. It calls the method `total_amount_payable()` of the same class to compute the total amount that needs to be paid. 
   This amount is stored in the variable `payable`.
2. It then calls another method `total_amount_paid()` of the same class to compute the total amount that has 
   already been paid by the account holder. This amount is stored in the variable `paid`.
3. Finally, it calculates the balance by subtracting the paid amount from the payable amount and returns this value.

Variables affected:
- `payable`: Holds the total amount that is payable by the account holder.
- `paid`: Holds the total amount that has already been paid by the account holder.

The purpose of this function is to provide a quick way to assess the financial standing of an account by 
calculating the difference between what has been charged and what has been paid, thus giving the current balance.

Returns:
    The current balance of the account, which could be a positive number (indicating the amount owed) or a negative 
    number (indicating overpayment)."
StudentListView,,"class StudentListView(LoginRequiredMixin, ListView):
    model = Student
    template_name = 'students/student_list.html'
",../../Django-School-Management-System/apps/students/views.py,views,views,class,,,122,"A view that displays a list of Student objects.

This class inherits from both LoginRequiredMixin and ListView to ensure that only authenticated users
can access the view and to provide a list-based display of data.

Attributes:
    model (Model): The Django model that this view will display. Set to the Student model.
    template_name (str): The path to the HTML template file used to render the student list page.

The class does not define its own methods but relies on the inherited functionality from Django's
generic ListView and the additional access control provided by LoginRequiredMixin.

Purpose:
    The purpose of this view is to fetch all Student objects from the database and render them in
    an HTML template. It requires users to be logged in to view the page, providing a measure of security.
    The Student objects will be passed to the specified template under the context variable 'object_list'
    or 'student_list' by default, where they can be iterated over and displayed to the user.

Variables Affected:
    None directly within the class definition; however, the underlying ListView and LoginRequiredMixin
    functionalities use various class attributes to control the query made to the database and to
    enforce the login requirement."
SubjectForm,,"class SubjectForm(ModelForm):
    prefix = 'Subject'


    class Meta:
        model = Subject
        fields = ['name']
",../../Django-School-Management-System/apps/corecode/forms.py,forms,forms,class,,,121,"A Django ModelForm subclass for creating a form to handle 'Subject' model instances.

The SubjectForm class inherits from Django's ModelForm, which is a helper class that
creates a form from a Django model. This particular form is configured to work with
the 'Subject' model.

Attributes:
    prefix (str): A string used to distinguish the form's fields from other form fields
                  when rendered in HTML. It helps to avoid name collisions when multiple
                  forms are used in the same HTML document.

Meta:
    A nested 'Meta' class is used to provide metadata to the SubjectForm class. This
    metadata tells Django which model the form is associated with and which fields of
    the model should be included in the form.

Meta Attributes:
    model (Django model class): The model class (Subject) that this form will be linked to.
                                This tells the SubjectForm which Django model it should
                                create a form for.

    fields (list): A list containing the names of the model fields that should be included
                   in the form. In this case, only the 'name' field of the Subject model
                   is included, meaning the form will only contain a single input for the
                   subject's name.

The SubjectForm class does not explicitly define any methods. It relies on the inherited
ModelForm functionality to handle the creation and processing of the form. The form can
be used in views to display an HTML form for a 'Subject' instance and to accept and
validate user input when creating or updating a subject's name."
StudentsConfig,,"class StudentsConfig(AppConfig):
    name = 'apps.students'

    def ready(self):
        import apps.students.signals
",../../Django-School-Management-System/apps/students/apps.py,apps,apps,class,,,119,"This method is called when the Django app 'students' is ready for use.
Its purpose is to ensure that the signal handlers for the app are imported and registered,
allowing the app to respond to various signals sent by Django during its lifecycle.

The method performs the following steps:
1. It imports the 'signals' module from the 'apps.students' package.
   This import statement has a side effect of registering any signal handlers defined
   in the 'signals' module with the Django signals framework.
2. As a result, the 'students' app is able to react to signals like pre_save, post_save,
   pre_delete, post_delete, etc., for the models defined within the app.
   
This method does not affect any variables directly; rather, it leverages the Django
framework's signal registration mechanism to set up signal handling for the app."
CorecodeConfig,,"class CorecodeConfig(AppConfig):
    name = 'apps.corecode'

    def ready(self):
        import apps.corecode.signals
",../../Django-School-Management-System/apps/corecode/apps.py,apps,apps,class,,,119,"Initializes the Corecode application configuration.

This method serves as an initialization hook for when the application is ready. It performs the following steps:

1. Imports the `signals` module from the `apps.corecode` package.

This import ensures that the signal handlers defined in the `signals` module are registered and ready to respond to the corresponding signals emitted by the application. The method does not affect any variables but relies on the import side effects for the signal registration process.

The `ready` method is typically called once by the Django framework when the application configuration is loaded and ready to be used, ensuring that all necessary setup tasks are performed before the application starts serving requests."
_delete_file,Deletes file from filesystem.,"def _delete_file(path):
    """"""Deletes file from filesystem.""""""
    if os.path.isfile(path):
        os.remove(path)
",../../Django-School-Management-System/apps/students/signals.py,signals,signals,function,,,117,"Deletes a file from the filesystem.

This function checks if the specified path points to an existing file in the filesystem and, if so, deletes it.

Args:
    path (str): The file system path to the file that is to be deleted.

Returns:
    None

The function makes use of the `os` module to interact with the file system. It uses `os.path.isfile` to check whether the path provided is a file, and `os.remove` to delete the file if it exists."
FinanceConfig,,"class FinanceConfig(AppConfig):
    name = 'apps.finance'

    def ready(self):
        import apps.finance.signals
",../../Django-School-Management-System/apps/finance/apps.py,apps,apps,class,,,116,"Initializes the Finance application configuration.

This method serves as an initialization hook for the AppConfig subclass
for the 'finance' application within a Django project. It is called when the
application is ready to start and is used here to import signal handlers
defined within the 'apps.finance' module.

Attributes:
    name (str): The name of the application, which is 'apps.finance' in this case.

Methods:
    ready(self): A method that Django calls when the application configuration is ready.
                 In this method, the 'apps.finance.signals' module is imported, which
                 allows the signal handlers to be connected and ready to respond to
                 signal events within the application. This could include things like
                 model saving signals, user login/logout signals, etc.

The method does not return anything and does not accept any parameters besides 'self'.
It is assumed that the 'apps.finance.signals' module contains necessary signal handler
registrations which will be executed upon import, thereby setting up the signal handling
mechanism for the 'finance' app."
StaffDetailView,,"class StaffDetailView(DetailView):
    model = Staff
    template_name = 'staffs/staff_detail.html'
",../../Django-School-Management-System/apps/staffs/views.py,views,views,class,,,100,"A view that extends Django's DetailView for displaying detailed information about a specific staff member.

Attributes:
    model (Model): The model that the detail view will display. This should be the 'Staff' model.
    template_name (str): The path to the template that will be used to render the detail view. This should be 'staffs/staff_detail.html'.

The view utilises Django's generic class-based detail view functionality to retrieve an individual staff member's data from the database and present it to a template. When the view is accessed, it performs the following steps:

1. It looks up the 'Staff' model by using the primary key provided in the URL or the current request context.
2. It retrieves the staff member's instance from the database.
3. It passes the staff member's instance to the template specified by 'template_name'.
4. The template renders the staff member's details, which can then be displayed to the user in a web browser.

The purpose of this view is to present detailed information, such as name, role, contact information, etc., about a single staff member to the end-user in a user-friendly format. It is typically used in staff management systems for administrators or users needing to view individual staff profiles."
bulk_invoice,,"@login_required
def bulk_invoice(request):
    return render(request, 'finance/bulk_invoice.html')
",../../Django-School-Management-System/apps/finance/views.py,views,views,function,,,99,"This function serves as a view in a Django web application that requires a user to be authenticated to access it. It is decorated with the `@login_required` decorator, ensuring that only authenticated users can call this function.

When an authenticated user accesses this function, it performs the following steps:

1. Instantiates an HttpRequest object named `request` which contains metadata about the request.
2. Calls the `render` function with the `request` object and the path to the 'bulk_invoice.html' template as arguments.
3. The `render` function processes the given template along with any context (not provided here) and returns an HttpResponse object with the rendered content.
4. The HttpResponse object is then returned to the user's browser, displaying the 'bulk_invoice.html' page.

The function does not take any additional parameters and does not modify any variables. It's primary purpose is to display the 'bulk_invoice.html' page to authenticated users.

Note: This function assumes that there is a valid 'bulk_invoice.html' template located in the 'finance' subdirectory of the templates directory in the Django project."
Meta,,"class Meta:
    verbose_name = 'Class'
    verbose_name_plural = 'Classes'
    ordering = ['name']
",../../Django-School-Management-System/apps/corecode/models.py,models,models,class,,,99,"This class `Meta` does not contain any functions/methods to describe. It is a simple class that
defines metadata which can be used to configure certain aspects of a class, often in the
context of a framework like Django.

Attributes:
    verbose_name (str): A human-readable name for an object, singular form. This is used to represent
        the object in a user-friendly way. In the context of Django, it is used for admin displays.

    verbose_name_plural (str): A human-readable name for an object, plural form. Similar to `verbose_name`,
        but used when referring to more than one instance of the object.

    ordering (list): A list of strings that indicates the default ordering of objects when they are
        retrieved from the database. Each string in the list corresponds to a field name by which the
        results should be ordered. In this class, objects are ordered by the 'name' field."
total_amount_payable,,"def total_amount_payable(self):
    return self.balance_from_previous_term + self.amount_payable()
",../../Django-School-Management-System/apps/finance/models.py,models,models,function,,,99,"Calculates the total amount payable.

This function computes the total amount that needs to be paid by adding two components:
1. The balance from the previous term, which is an attribute of the instance on which this method is being called.
2. The amount that is currently payable, which is determined by invoking the `amount_payable` method of the instance.

The purpose of this function is to provide a sum of the outstanding balance from a previous term with the current term's payable amount, giving a comprehensive view of the total financial obligation as of now.

The function affects and utilizes the following variables:
- `self.balance_from_previous_term`: An attribute representing the leftover balance from the previous term.
- `self.amount_payable()`: A method that when called, calculates and returns the current payable amount.

Returns:
    float: The total amount payable, which is the sum of the previous term's balance and the current term's payable amount."
StaffDeleteView,,"class StaffDeleteView(DeleteView):
    model = Staff
    success_url = reverse_lazy('staff-list')
",../../Django-School-Management-System/apps/staffs/views.py,views,views,class,,,98,"A view that handles the deletion of a Staff object.

This class-based view, inheriting from Django's DeleteView, is responsible for deleting an instance of the `Staff` model from the database. Upon successful deletion, it redirects the user to the URL named 'staff-list'.

Attributes:
    model (django.db.models.Model): The model that this view will act upon. In this case, the `Staff` model is specified, indicating that this view will be used to delete instances of Staff.
    
    success_url (str or django.urls.reverse_lazy): The URL to redirect to after successfully deleting an object. Here, `reverse_lazy` is used to lazily resolve the URL named 'staff-list'. This means the URL will not be resolved until it is accessed, allowing for use in modules where URLs have not yet been fully initialized.

The `StaffDeleteView` does not explicitly define methods. Instead, it relies on the methods provided by Django's DeleteView. When a DELETE request is made to this view, the following steps are taken by the inherited DeleteView logic:

1. The view retrieves the Staff object that matches the provided primary key from the URL.
2. The view then prompts the user for confirmation of the delete action.
3. Upon user confirmation, the view deletes the Staff object from the database.
4. Finally, the view redirects the user to the `success_url`, which is the URL named 'staff-list'.

By using the `StaffDeleteView`, the process of deleting a staff member is encapsulated into a reusable and consistent interface, adhering to the DRY (Don't Repeat Yourself) principle."
apps,,"from django.apps import AppConfig


class ResultConfig(AppConfig):
    name = 'apps.result'
",../../Django-School-Management-System/apps/result/apps.py,apps,,module,0.0,,92,nan
apps,,"from django.apps import AppConfig


class StaffsConfig(AppConfig):
    name = 'apps.staffs'
",../../Django-School-Management-System/apps/staffs/apps.py,apps,,module,0.0,,92,nan
__str__,,"def __str__(self):
    return f'{self.student} {self.session} {self.term} {self.subject}'
",../../Django-School-Management-System/apps/result/models.py,models,models,function,,,90,"This method is used to represent the object in a string format. It overrides the default `__str__` method to provide a more meaningful string representation of the object. The method returns a formatted string that includes details of a student's record, presumably for a class or a session.

The method constructs a string by accessing the following attributes of the object:
- `self.student`: Presumably an attribute containing information about the student, such as name or ID.
- `self.session`: An attribute that likely holds information about the current session or academic period.
- `self.term`: An attribute indicating the term within the session, such as 'Spring', 'Fall', etc.
- `self.subject`: An attribute containing details about the subject or course the student is enrolled in.

The formatted string is created by concatenating these attributes with spaces in between, resulting in a single line of text with the student's information followed by the session, term, and subject details.

The purpose of this method is to provide a human-readable representation of the object when it is printed or converted to a string, which can be helpful for logging, debugging, or displaying information to users.

Note: The method does not modify any variables; it only reads the attributes of the object and returns a string based on their values.

Example of the returned string format:
    'John Doe 2023 Spring Mathematics'"
get_absolute_url,,"def get_absolute_url(self):
    return reverse('student-detail', kwargs={'pk': self.pk})
",../../Django-School-Management-System/apps/students/models.py,models,models,function,,,89,"Constructs and returns an absolute URL for a particular instance of a student.

The method uses Django's `reverse` function to generate the URL by:
- Providing the name of the URL pattern ('student-detail') which is typically defined in the application's URL configuration.
- Supplying keyword arguments (kwargs) where 'pk' is set to the instance's primary key (self.pk).

This absolute URL is used to access the detail view of a specific student instance.

Returns:
    str: The absolute URL pointing to the detail view of the student with the primary key `self.pk`."
get_absolute_url,,"def get_absolute_url(self):
    return reverse('invoice-detail', kwargs={'pk': self.pk})
",../../Django-School-Management-System/apps/finance/models.py,models,models,function,,,89,"Constructs the absolute URL for an invoice instance.

This method reverses the URL pattern named 'invoice-detail' using the instance's primary key (`pk`). The primary key is used as a keyword argument to uniquely identify the invoice instance for which the URL is being constructed.

Returns:
    str: The absolute URL string which points to the detail view of this particular invoice.

Example:
    >>> invoice = Invoice(pk=1)
    >>> invoice.get_absolute_url()
    '/invoice/1/detail/'

Where '/invoice/1/detail/' is the URL pattern defined in the URLs configuration, with 'invoice-detail' as its name and the invoice's primary key (1 in this case) included in the URL."
IndexView,,"class IndexView(LoginRequiredMixin, TemplateView):
    template_name = 'index.html'
",../../Django-School-Management-System/apps/corecode/views.py,views,views,class,,,84,"This class represents a view that renders a template for the index page of a website.
It inherits from both LoginRequiredMixin and TemplateView.

Attributes:
    template_name (str): A string that specifies the path to the template that this view will render.
        In this case, the template is 'index.html'.

The LoginRequiredMixin ensures that the view can only be accessed by logged-in users. If a user is not authenticated,
they will be redirected to the login page.

The TemplateView is a class provided by Django for rendering a specific template along with a context.

Purpose:
    - To serve the 'index.html' template to a user who has successfully logged in.
    - To restrict access to the index page to only authenticated users, ensuring that only authorized
      individuals can view the content of this page.

No additional functions are defined within this class, as it relies on the inherited behavior from both mixins to serve its purpose."
InvoiceListView,,"class InvoiceListView(LoginRequiredMixin, ListView):
    model = Invoice
",../../Django-School-Management-System/apps/finance/views.py,views,views,class,,,73,"A view that lists invoices and requires the user to be logged in to access it.

This view extends `ListView`, a generic view provided by Django to display a list of objects, and integrates
`LoginRequiredMixin` to ensure that only authenticated users can access the view. The view is specifically
designed to work with objects of the `Invoice` model.

Attributes:
    model (Model): The model that this view will display a list of. Set to the `Invoice` model class.

The view does not explicitly define methods like `get_queryset` or `get_context_data`, which means it relies on
the default implementation provided by Django's `ListView`. As a result, it will display all instances of the
`Invoice` model, presented in a template which needs to be defined separately (typically 'invoice_list.html' or
similar, following Django's default naming conventions).

The `LoginRequiredMixin` ensures that the `dispatch` method will check if the user is authenticated before
proceeding with the usual view logic. If the user is not authenticated, they will be redirected to the login
page.

Summary of Steps:
1. The view inherits from both `LoginRequiredMixin` and `ListView`.
2. It specifies the `Invoice` model as the source of list items.
3. When a request is made to the view, `LoginRequiredMixin` checks if the user is authenticated.
4. If the user is authenticated, `ListView` provides the list of all `Invoice` instances to be displayed.
5. If the user is not authenticated, they are redirected to the login page."
total_score,,"def total_score(self):
    return self.test_score + self.exam_score
",../../Django-School-Management-System/apps/result/models.py,models,models,function,,,68,"Calculates the total score for a student by adding together the test score and the exam score.

This function does not take any parameters besides 'self', which refers to the instance of the class
that this method is part of. It accesses the 'test_score' and 'exam_score' attributes of the instance.

Returns:
    int: The sum of 'test_score' and 'exam_score', which represents the total score of the student."
Meta,,"class Meta:
    ordering = ['surname', 'firstname', 'other_name']
",../../Django-School-Management-System/apps/students/models.py,models,models,class,,,66,"The class `Meta` is a simple structure that holds an attribute `ordering` which is a list of strings.

Attributes:
    ordering (list): A class-level attribute that defines the order of sorting criteria as a list of strings.

The `ordering` attribute represents the fields by which objects, presumably of another class, should be sorted. 
The fields specified are 'surname', 'firstname', and 'other_name', in that order of priority. This means that 
when sorting objects, one should first sort by 'surname', then within those with the same surname, sort by 
'firstname', and finally within those with the same firstname, sort by 'other_name'.

The `Meta` class does not contain any methods and is likely meant to be used as a configuration class within 
another class, providing metadata about how instances of that other class should be handled in terms of sorting.

Example:
    class Person:
        class Meta:
            ordering = ['surname', 'firstname', 'other_name']

In the example above, the `Meta` class is nested within a `Person` class. It specifies that when instances of 
Person are sorted, they should be sorted by their 'surname', then 'firstname', and then 'other_name' attributes."
score_grade,,"def score_grade(score):
    if score <= 10:
        return 'A'
",../../Django-School-Management-System/apps/result/utils.py,utils,utils,function,,,63,"Given a numeric score, this function assigns a grade based on the score value.

The function uses one parameter:
- score: A numeric value representing a score that is intended to be graded.

The function performs the following steps:
1. It checks if the 'score' is less than or equal to 10.
2. If the condition is met, it returns the grade 'A'.

Note: This function currently only returns a grade 'A' for scores that are 10 or below.
      It does not handle scoring for any other ranges or return a default value for scores above 10.
      The function is incomplete and would need additional conditions to handle a full range of scores."
utils,,"def score_grade(score):
    if score <= 10:
        return 'A'
",../../Django-School-Management-System/apps/result/utils.py,utils,,module,0.0,,63,nan
grade,,"def grade(self):
    return score_grade(self.total_score())
",../../Django-School-Management-System/apps/result/models.py,models,models,function,,,60,"This function calculates the grade associated with a student's total score.

Firstly, it calls the 'total_score' method of the same class to retrieve the student's total score.
Then, it passes this total score to the 'score_grade' function to determine the student's grade based on that score.

The function affects the following variables:
- 'self': This is the instance of the class for which the grade is being calculated.
- 'self.total_score()': This method is called on the instance to get the total score that the student has earned.

The main purpose of this function is to provide a convenient way to obtain the grade of a student based on their total score, by abstracting away the details of how the score is computed and how the grade is determined from the score.

Returns:
- The grade as determined by the 'score_grade' function, which is presumably a string or some form of categorical representation of the student's performance level."
Meta,,"class Meta:
    model = StudentClass
    fields = ['name']
",../../Django-School-Management-System/apps/corecode/forms.py,forms,forms,class,,,59,"A class-level docstring that provides information about the 'Meta' class that is likely intended to be used as a nested class within a Django model form or similar construct.

Attributes:
    model (Model): A Django model class that this Meta class is associated with, specified as 'StudentClass'. This indicates which model the form will be associated with when the Meta class is used.
    fields (list of str): A list containing the field names that should be included in the form. In this case, it's a single-element list with the string 'name', which means only the 'name' field of the 'StudentClass' model will be included in the form.

The 'Meta' class itself does not contain any functions or methods. It solely serves the purpose of providing metadata to the enclosing class about the model and fields that should be used for form generation or similar operations."
__init__,,"default_app_config = 'apps.students.apps.StudentsConfig'
",../../Django-School-Management-System/apps/students/__init__.py,__init__,,module,0.0,,57,nan
__init__,,"default_app_config = 'apps.corecode.apps.CorecodeConfig'
",../../Django-School-Management-System/apps/corecode/__init__.py,__init__,,module,0.0,,57,nan
ResultConfig,,"class ResultConfig(AppConfig):
    name = 'apps.result'
",../../Django-School-Management-System/apps/result/apps.py,apps,apps,class,,,56,"This class `ResultConfig` is a Django application configuration class, which is used to set up some configurations for an app named 'result' within a Django project. It is a subclass of `AppConfig`, which is a class provided by the Django framework for application configurations.

Attributes:
    name (str): It is a class-level attribute that defines the full Python path to the application. In this case, it is set to 'apps.result', which suggests that the application is within a directory named 'apps', and the specific application name is 'result'.

The purpose of this class is to allow Django to recognize the 'result' application and configure it according to the settings provided by the class. This can include registering the app with the project, configuring the app's signals, or setting up app-specific settings.

The class doesn't define any methods, only the `name` attribute, which is mandatory for any AppConfig subclass. This attribute tells Django what the name of the app is and where to find it. There are no other variables affected by this class.

Note: This class does not contain any methods other than the special method `__init__` inherited from the `AppConfig` superclass, which is not shown in the code snippet provided. The docstring only applies to the configuration aspect represented by the `name` attribute."
StaffsConfig,,"class StaffsConfig(AppConfig):
    name = 'apps.staffs'
",../../Django-School-Management-System/apps/staffs/apps.py,apps,apps,class,,,56,"A Django application configuration class named 'StaffsConfig' representing the 'staffs' app.

Attributes:
    name (str): A string that defines the full Python path to the application. It is used by Django
                to identify the application within the project. Here, it is set to 'apps.staffs', which
                indicates that this application is located under the 'apps' package and is named 'staffs'.

Purpose:
    This class serves as a configuration class for the 'staffs' Django application. It is a subclass of
    'AppConfig', which is a standard Django class used for application configurations. By setting the 'name'
    attribute, it provides Django with the necessary information to properly recognize and register the
    application within the overall project.

Usage:
    To use this configuration class, it should be referenced in the 'INSTALLED_APPS' setting of the Django
    project's settings file. This allows Django's application registry to include the 'staffs' application
    and make its models and other components available for use."
__init__,,"default_app_config = 'apps.finance.apps.FinanceConfig'
",../../Django-School-Management-System/apps/finance/__init__.py,__init__,,module,0.0,,55,nan
StaffListView,,"class StaffListView(ListView):
    model = Staff
",../../Django-School-Management-System/apps/staffs/views.py,views,views,class,,,49,"A view that inherits from Django's ListView to display a list of Staff objects.

This view automatically fetches all Staff objects from the database, using the Staff model as its data source.

Attributes:
    model: A Django model class that represents the staff members. It is used by the ListView to determine which type of objects to query from the database.

The `StaffListView` does not define any additional methods or attributes, meaning it relies on the default behavior provided by Django's ListView. The default behavior includes:
- Fetching all Staff objects from the database.
- Rendering a template (not specified in this class, but conventionally named 'staff_list.html') with the context containing the Staff objects list.
- Providing pagination functionality if configured in the project settings or the ListView."
__str__,,"def __str__(self):
    return f'{self.student}'
",../../Django-School-Management-System/apps/finance/models.py,models,models,function,,,48,"Converts the object to a string representation by returning the 'student' attribute.

This method overrides the built-in `__str__` method to provide a meaningful string
representation of the object. When the object is converted to a string or printed, 
the `student` attribute's string representation is returned.

Returns:
    str: The string representation of the 'student' attribute of the object.

Example:
    Assuming that `self.student` is an object with a meaningful `__str__` representation,
    calling `str(instance_of_this_class)` or `print(instance_of_this_class)` will output
    the string representation of `self.student`."
Meta,,"class Meta:
    ordering = ['student', 'term']
",../../Django-School-Management-System/apps/finance/models.py,models,models,class,,,47,"This class `Meta` is a simple container with a single class attribute `ordering`.

Attributes:
    ordering (list): A list of strings that defines the order of elements, specifically for 'student' and 'term'.

The `ordering` list is used to specify the sequence in which elements should be considered or processed, with 'student' having precedence over 'term'."
__str__,,"def __str__(self):
    return self.name
",../../Django-School-Management-System/apps/corecode/models.py,models,models,function,,,40,"Converts the object to its string representation by returning its 'name' attribute.

This method overrides the special method __str__ that is used to create a string representation of objects.
When an instance of this class is passed to the str() function or used in a context where a string is expected,
the method will return the value of the instance's 'name' attribute.

Variables:
- self (object): The instance of the class for which the string representation is being created.

Returns:
- str: The string representation of the object, specifically the value of the 'name' attribute.

Example:
    If an instance of this class with the name 'Alice' is used, 
    calling str(instance) will return 'Alice'."
Meta,,"class Meta:
    ordering = ['subject']
",../../Django-School-Management-System/apps/result/models.py,models,models,class,,,39,"This class `Meta` does not contain any methods, but it has a single class variable `ordering`.

Class Variable:
    ordering (list): A class attribute which is a list that stores the order in which objects are intended to be sorted or listed.
                     The list contains strings that represent the field names of another class or database model. In this case, it contains a single element 'subject',
                     indicating that objects should be sorted or listed based on the 'subject' field.

The class does not perform any operations as it lacks methods. It serves as a configuration holder, potentially to be used as a Meta inner class in a Django model
or similar ORM (Object-Relational Mapping) system where such ordering preferences are specified for record retrieval or display purposes."
admin,,"from django.contrib import admin
",../../Django-School-Management-System/apps/result/admin.py,admin,,module,0.0,,33,nan
admin,,"from django.contrib import admin
",../../Django-School-Management-System/apps/finance/admin.py,admin,,module,0.0,,33,nan
admin,,"from django.contrib import admin
",../../Django-School-Management-System/apps/staffs/admin.py,admin,,module,0.0,,33,nan
admin,,"from django.contrib import admin
",../../Django-School-Management-System/apps/students/admin.py,admin,,module,0.0,,33,nan
__init__,,,../../Django-School-Management-System/apps/result/__init__.py,__init__,,module,0.0,,0,nan
__init__,,,../../Django-School-Management-System/school_app/__init__.py,__init__,,module,0.0,,0,nan
__init__,,,../../Django-School-Management-System/apps/staffs/__init__.py,__init__,,module,0.0,,0,nan
__init__,,,../../Django-School-Management-System/apps/__init__.py,__init__,,module,0.0,,0,nan
